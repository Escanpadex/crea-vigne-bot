<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Trading Bitget Futures - Strat√©gie MACD TOP 20</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        
        .status-dot.online {
            background: #28a745;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }
        
        .btn-success {
            background: linear-gradient(45deg, #28a745, #1e7e34);
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .logs {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .balance-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #f8f9fa;
            margin-bottom: 8px;
            border-radius: 6px;
        }
        
        .price-display {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin: 10px 0;
        }
        
        .indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .indicator.buy {
            background: #28a745;
            color: white;
        }
        
        .indicator.sell {
            background: #dc3545;
            color: white;
        }
        
        .indicator.hold {
            background: #ffc107;
            color: #212529;
        }
        
        .version {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .top20-list {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
        }
        
        .pair-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            font-size: 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .pair-item:last-child {
            border-bottom: none;
        }
        
        .scanning {
            background: #ffc107;
            color: black;
        }
        
        .position-item {
            background: #e8f5e8;
            border: 1px solid #28a745;
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="version">üìÖ v2.0 - Strat√©gie MACD TOP 20 Volume - 29/05/2025</div>
    
    <div class="container">
        <div class="header">
            <h1>üöÄ Bot Trading Bitget Futures</h1>
            <p>Strat√©gie MACD - TOP 20 Volume - Levier 2x - Trailing Stop 1%</p>
        </div>
        
        <div class="grid">
            <!-- Configuration -->
            <div class="card">
                <h3>‚öôÔ∏è Configuration API</h3>
                <div class="status">
                    <div class="status-dot" id="connectionStatus"></div>
                    <span id="connectionText">D√©connect√©</span>
                </div>
                
                <div class="form-group">
                    <label>API Key:</label>
                    <input type="password" id="apiKey" placeholder="Votre API Key Bitget">
                </div>
                
                <div class="form-group">
                    <label>Secret Key:</label>
                    <input type="password" id="secretKey" placeholder="Votre Secret Key">
                </div>
                
                <div class="form-group">
                    <label>Passphrase:</label>
                    <input type="password" id="passphrase" placeholder="Votre Passphrase">
                </div>
                
                <button class="btn" onclick="testConnection()">üîó Tester la connexion</button>
                <button class="btn btn-success" onclick="saveKeys()" style="margin-top: 10px;">üíæ Sauvegarder les cl√©s</button>
                <button class="btn btn-danger" onclick="clearSavedKeys()" style="margin-top: 5px; font-size: 12px; padding: 8px 15px;">üóëÔ∏è Effacer les cl√©s sauv√©es</button>
            </div>
            
            <!-- Param√®tres Strat√©gie -->
            <div class="card">
                <h3>üìä Param√®tres Strat√©gie MACD</h3>
                
                <div class="form-group">
                    <label>Capital √† utiliser (% du total):</label>
                    <input type="number" id="capitalPercent" value="5" min="1" max="20" step="1">
                    <small>5% du capital √ó levier 2x par position</small>
                </div>
                
                <div class="form-group">
                    <label>Levier:</label>
                    <select id="leverage">
                        <option value="2" selected>2x (Recommand√©)</option>
                        <option value="3">3x</option>
                        <option value="5">5x</option>
                        <option value="10">10x</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Trailing Stop (%):</label>
                    <input type="number" id="trailingStop" value="1" min="0.5" max="5" step="0.1">
                    <small>Recul maximum autoris√©</small>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="startBot()" id="startBtn">‚ñ∂Ô∏è D√©marrer Strat√©gie</button>
                    <button class="btn btn-danger" onclick="stopBot()" id="stopBtn" disabled>‚èπÔ∏è Arr√™ter Bot</button>
                </div>
                
                <div style="margin-top: 15px;">
                    <button class="btn" onclick="scanTop20Volume()" style="width: 100%;">üîç Scanner TOP 20 Volume</button>
                </div>
            </div>
        </div>
        
        <div class="grid">
            <!-- TOP 20 Paires -->
            <div class="card">
                <h3>üìà TOP 20 Volume (Surveillance)</h3>
                <div style="margin-bottom: 10px;">
                    <strong>Paire en cours d'analyse:</strong> <span id="currentScanPair">--</span>
                </div>
                <div class="top20-list" id="top20List">
                    <div class="pair-item">
                        <span>Chargement...</span>
                        <span>--</span>
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Derni√®re MAJ:</strong> <span id="lastScanTime">--</span>
                </div>
            </div>
            
            <!-- Positions Ouvertes -->
            <div class="card">
                <h3>üíº Positions Ouvertes</h3>
                <div id="positionsContainer">
                    <div style="text-align: center; color: #666; padding: 20px;">
                        Aucune position ouverte
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <strong>Capital utilis√©:</strong> <span id="usedCapital">0 USDT</span> / 
                    <strong>Disponible:</strong> <span id="availableCapital">-- USDT</span>
                </div>
            </div>
        </div>
        
        <div class="grid">
            <!-- Balance -->
            <div class="card">
                <h3>üí≥ Balance Futures</h3>
                <div id="balanceContainer">
                    <div class="balance-item">
                        <span>USDT Total:</span>
                        <span id="usdtBalance">--</span>
                    </div>
                    <div class="balance-item">
                        <span>√âquit√©:</span>
                        <span id="totalEquity">--</span>
                    </div>
                </div>
                <button class="btn" onclick="refreshBalance()" style="width: 100%; margin-top: 10px;">üîÑ Actualiser</button>
            </div>
            
            <!-- Statistiques -->
            <div class="card">
                <h3>üìä Statistiques Bot</h3>
                <div class="balance-item">
                    <span>Scans effectu√©s:</span>
                    <span id="totalScans">0</span>
                </div>
                <div class="balance-item">
                    <span>Signaux d√©tect√©s:</span>
                    <span id="totalSignals">0</span>
                </div>
                <div class="balance-item">
                    <span>Positions ouvertes:</span>
                    <span id="totalOpenPositions">0</span>
                </div>
                <div class="balance-item">
                    <span>Uptime:</span>
                    <span id="botUptime">00:00:00</span>
                </div>
            </div>
        </div>
        
        <!-- Logs -->
        <div class="card">
            <h3>üìù Logs de Trading</h3>
            <div class="logs" id="logs">
                [INFO] Bot de trading MACD TOP 20 initialis√©...<br>
                [INFO] Strat√©gie: 5% capital √ó 2x levier √ó 1% trailing stop<br>
                [INFO] En attente de configuration API...<br>
            </div>
            <button class="btn" onclick="clearLogs()" style="margin-top: 10px;">üóëÔ∏è Effacer logs</button>
        </div>
    </div>

    <script>
        // Variables globales
        const API_BASE = 'https://api.crea-vigne.fr/api';
        let botRunning = false;
        let volumeScanInterval = null;
        let tradingLoopInterval = null;
        let statsInterval = null;
        let botStartTime = null;
        
        // Donn√©es du bot
        let top20Pairs = [];
        let currentScanIndex = 0;
        let openPositions = [];
        let botStats = {
            totalScans: 0,
            totalSignals: 0,
            totalPositions: 0
        };
        
        // Configuration
        let config = {
            apiKey: '',
            secretKey: '',
            passphrase: '',
            capitalPercent: 5,
            leverage: 2,
            trailingStop: 1.0
        };
        
        let balance = { USDT: 0, totalEquity: 0 };
        
        // === FONCTIONS UTILITAIRES ===
        function log(message, type = 'INFO') {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] [${type}] ${message}<br>`;
            logs.innerHTML += logMessage;
            logs.scrollTop = logs.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }
        
        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }
        
        function updateStats() {
            document.getElementById('totalScans').textContent = botStats.totalScans;
            document.getElementById('totalSignals').textContent = botStats.totalSignals;
            document.getElementById('totalOpenPositions').textContent = openPositions.length;
            
            if (botStartTime) {
                const elapsed = Date.now() - botStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('botUptime').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        // === GESTION DES CL√âS API ===
        function saveKeys() {
            const keys = {
                apiKey: document.getElementById('apiKey').value,
                secretKey: document.getElementById('secretKey').value,
                passphrase: document.getElementById('passphrase').value
            };
            
            if (keys.apiKey && keys.secretKey && keys.passphrase) {
                savedKeys = keys;
                log('üîë Cl√©s sauvegard√©es en m√©moire', 'SUCCESS');
            } else {
                log('‚ö†Ô∏è Veuillez remplir tous les champs avant de sauvegarder', 'WARNING');
            }
        }
        
        function loadKeys() {
            // Simplified key loading for demo
            return false;
        }
        
        function clearSavedKeys() {
            document.getElementById('apiKey').value = '';
            document.getElementById('secretKey').value = '';
            document.getElementById('passphrase').value = '';
            savedKeys = {};
            log('üóëÔ∏è Cl√©s effac√©es', 'INFO');
        }
        
        // === API REQUESTS ===
        async function makeRequest(endpoint, options = {}) {
            try {
                const timestamp = Date.now().toString();
                const headers = {
                    'Content-Type': 'application/json',
                    'apikey': config.apiKey,
                    'secretkey': config.secretKey,
                    'passphrase': config.passphrase,
                    'timestamp': timestamp,
                    ...options.headers
                };
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    ...options,
                    headers
                });
                
                return await response.json();
            } catch (error) {
                log(`Erreur API: ${error.message}`, 'ERROR');
                return null;
            }
        }
        
        // === CONNEXION API ===
        async function testConnection() {
            config.apiKey = document.getElementById('apiKey').value;
            config.secretKey = document.getElementById('secretKey').value;
            config.passphrase = document.getElementById('passphrase').value;
            
            if (!config.apiKey || !config.secretKey || !config.passphrase) {
                alert('Veuillez remplir tous les champs API');
                return;
            }
            
            log('üîÑ Test de connexion √† Bitget Futures...');
            
            const result = await makeRequest('/bitget/api/v2/mix/account/accounts?productType=USDT-FUTURES');
            
            if (result && result.code === '00000') {
                document.getElementById('connectionStatus').classList.add('online');
                document.getElementById('connectionText').textContent = 'Connect√© (Futures)';
                log('‚úÖ Connexion r√©ussie √† Bitget Futures!', 'SUCCESS');
                await refreshBalance();
                return true;
            } else {
                log('‚ùå √âchec de la connexion. V√©rifiez vos cl√©s API Futures.', 'ERROR');
                return false;
            }
        }
        
        // === BALANCE ===
        async function refreshBalance() {
            const result = await makeRequest('/bitget/api/v2/mix/account/accounts?productType=USDT-FUTURES');
            
            if (result && result.data && result.data.length > 0) {
                const account = result.data[0];
                balance.USDT = parseFloat(account.available || 0);
                balance.totalEquity = parseFloat(account.usdtEquity || account.equity || 0);
                
                document.getElementById('usdtBalance').textContent = balance.USDT.toFixed(2);
                document.getElementById('totalEquity').textContent = balance.totalEquity.toFixed(2);
                
                // Calculer capital disponible
                const usedCapital = openPositions.reduce((sum, pos) => sum + pos.size, 0);
                const availableCapital = balance.totalEquity * (config.capitalPercent / 100) * config.leverage - usedCapital;
                
                document.getElementById('usedCapital').textContent = usedCapital.toFixed(2);
                document.getElementById('availableCapital').textContent = Math.max(0, availableCapital).toFixed(2);
                
                log('üí∞ Balance mise √† jour', 'INFO');
            } else {
                log('‚ö†Ô∏è Impossible de r√©cup√©rer la balance', 'WARNING');
            }
        }
        
        // === SCANNER TOP 20 VOLUME ===
        async function scanTop20Volume() {
            try {
                log('üîç Scan des volumes TOP 20 en cours...', 'INFO');
                
                const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/tickers?productType=usdt-futures`);
                const data = await response.json();
                
                if (data.code === '00000' && data.data) {
                    // Filtrer et trier par volume
                    const validPairs = data.data
                        .filter(pair => {
                            const volume = parseFloat(pair.usdtVolume || 0);
                            return volume > 10000000 && pair.symbol.endsWith('USDT'); // Min 10M volume + USDT pairs
                        })
                        .sort((a, b) => parseFloat(b.usdtVolume) - parseFloat(a.usdtVolume))
                        .slice(0, 20);
                    
                    top20Pairs = validPairs;
                    currentScanIndex = 0;
                    
                    // Mise √† jour de l'affichage
                    updateTop20Display();
                    
                    const totalVolume = validPairs.reduce((sum, pair) => sum + parseFloat(pair.usdtVolume), 0);
                    log(`‚úÖ TOP 20 mis √† jour: ${validPairs.length} paires, Volume total: ${formatNumber(totalVolume)}`, 'SUCCESS');
                    
                    // Afficher le TOP 5
                    validPairs.slice(0, 5).forEach((pair, index) => {
                        log(`#${index + 1} ${pair.symbol}: ${formatNumber(pair.usdtVolume)} vol`, 'INFO');
                    });
                    
                    document.getElementById('lastScanTime').textContent = new Date().toLocaleTimeString();
                    return true;
                } else {
                    log('‚ùå Erreur lors du scan des volumes', 'ERROR');
                    return false;
                }
            } catch (error) {
                log(`‚ùå Erreur scanner: ${error.message}`, 'ERROR');
                return false;
            }
        }
        
        function updateTop20Display() {
            const container = document.getElementById('top20List');
            container.innerHTML = '';
            
            top20Pairs.forEach((pair, index) => {
                const item = document.createElement('div');
                item.className = 'pair-item';
                if (index === currentScanIndex) {
                    item.classList.add('scanning');
                }
                
                item.innerHTML = `
                    <span>#${index + 1} ${pair.symbol}</span>
                    <span>${formatNumber(pair.usdtVolume)}</span>
                `;
                container.appendChild(item);
            });
        }
        
        // === R√âCUP√âRATION DES DONN√âES KLINES 5 MINUTES ===
        async function getKlineData(symbol, limit = 50) {
            try {
                // R√©cup√©rer les klines 5 minutes
                const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/candles?symbol=${symbol}&productType=usdt-futures&granularity=5m&limit=${limit}`);
                const data = await response.json();
                
                if (data.code === '00000' && data.data) {
                    // Convertir en format utilisable [timestamp, open, high, low, close, volume]
                    return data.data.map(candle => ({
                        timestamp: parseInt(candle[0]),
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    })).reverse(); // Bitget retourne du plus r√©cent au plus ancien
                }
            } catch (error) {
                console.error(`Erreur klines ${symbol}:`, error);
            }
            return [];
        }
        
        // === CALCUL MACD R√âEL ===
        function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            if (prices.length < slowPeriod + signalPeriod) {
                return { macd: 0, signal: 0, histogram: 0, crossover: false };
            }
            
            // Calcul des EMA
            function calculateEMA(data, period) {
                const multiplier = 2 / (period + 1);
                let ema = data[0];
                const result = [ema];
                
                for (let i = 1; i < data.length; i++) {
                    ema = (data[i] * multiplier) + (ema * (1 - multiplier));
                    result.push(ema);
                }
                return result;
            }
            
            // Calculer EMA 12 et EMA 26
            const ema12 = calculateEMA(prices, fastPeriod);
            const ema26 = calculateEMA(prices, slowPeriod);
            
            // Calculer MACD line
            const macdLine = [];
            for (let i = slowPeriod - 1; i < prices.length; i++) {
                macdLine.push(ema12[i] - ema26[i]);
            }
            
            // Calculer Signal line (EMA 9 du MACD)
            const signalLine = calculateEMA(macdLine, signalPeriod);
            
            // R√©cup√©rer les 2 derni√®res valeurs pour d√©tecter le croisement
            const currentMacd = macdLine[macdLine.length - 1];
            const previousMacd = macdLine[macdLine.length - 2];
            const currentSignal = signalLine[signalLine.length - 1];
            const previousSignal = signalLine[signalLine.length - 2];
            
            // Calculer histogram
            const currentHistogram = currentMacd - currentSignal;
            
            // D√©tecter croisement haussier : MACD croise au-dessus de Signal
            const crossover = (previousMacd <= previousSignal) && (currentMacd > currentSignal);
            
            return {
                macd: currentMacd,
                signal: currentSignal,
                histogram: currentHistogram,
                crossover: crossover,
                macdLine: macdLine,
                signalLine: signalLine
            };
        }
        
        // === ANALYSE MACD D'UNE PAIRE (CORRIG√âE) ===
        async function analyzePairMACD(symbol) {
            try {
                // R√©cup√©rer les donn√©es klines 5 minutes
                const klines = await getKlineData(symbol, 50);
                
                if (klines.length < 35) {
                    return { symbol, signal: 'HOLD', strength: 0, reason: 'Donn√©es insuffisantes' };
                }
                
                // Extraire les prix de cl√¥ture
                const closePrices = klines.map(k => k.close);
                const currentPrice = closePrices[closePrices.length - 1];
                const volume24h = klines.slice(-288).reduce((sum, k) => sum + k.volume, 0); // 24h = 288 p√©riodes de 5min
                
                // Calculer MACD
                const macdData = calculateMACD(closePrices);
                
                let macdSignal = 'HOLD';
                let signalStrength = 0;
                let reason = '';
                
                // ‚úÖ CONDITION EXACTE : Croisement haussier MACD d√©tect√©
                if (macdData.crossover) {
                    macdSignal = 'BUY';
                    // Force du signal bas√©e sur l'amplitude du histogram et du volume
                    signalStrength = Math.abs(macdData.histogram) * 100 + (volume24h / 1000000);
                    reason = `Croisement MACD haussier d√©tect√©! MACD: ${macdData.macd.toFixed(4)} > Signal: ${macdData.signal.toFixed(4)}`;
                } else {
                    reason = `Pas de croisement. MACD: ${macdData.macd.toFixed(4)}, Signal: ${macdData.signal.toFixed(4)}`;
                }
                
                return {
                    symbol,
                    signal: macdSignal,
                    strength: signalStrength,
                    price: currentPrice,
                    volume24h: volume24h,
                    macd: macdData.macd,
                    macdSignal: macdData.signal,
                    histogram: macdData.histogram,
                    crossover: macdData.crossover,
                    reason: reason
                };
                
            } catch (error) {
                console.error(`Erreur analyse MACD ${symbol}:`, error);
                return { symbol, signal: 'HOLD', strength: 0, reason: `Erreur: ${error.message}` };
            }
        }
        
        // === GESTION DES POSITIONS ===
        function calculatePositionSize() {
            const maxPositionValue = (balance.totalEquity * config.capitalPercent / 100) * config.leverage;
            return Math.max(maxPositionValue, 10); // Minimum 10 USDT
        }
        
        function hasOpenPosition(symbol) {
            return openPositions.some(pos => pos.symbol === symbol && pos.status === 'OPEN');
        }
        
        async function openPosition(symbol, analysis) {
            if (hasOpenPosition(symbol)) {
                return false;
            }
            
            const positionSize = calculatePositionSize();
            if (positionSize < 10) {
                log(`‚ö†Ô∏è Capital insuffisant pour ouvrir position sur ${symbol}`, 'WARNING');
                return false;
            }
            
            try {
                const position = {
                    id: Date.now(),
                    symbol: symbol,
                    side: 'LONG',
                    size: positionSize,
                    entryPrice: analysis.price,
                    currentPrice: analysis.price,
                    highestPrice: analysis.price,
                    trailingStopPrice: analysis.price * (1 - config.trailingStop / 100),
                    status: 'OPEN',
                    timestamp: new Date().toISOString(),
                    pnl: 0
                };
                
                openPositions.push(position);
                botStats.totalPositions++;
                
                log(`üöÄ Position ouverte: ${symbol} LONG ${positionSize.toFixed(2)} USDT @ ${analysis.price.toFixed(4)}`, 'SUCCESS');
                log(`üìç Trailing Stop: ${position.trailingStopPrice.toFixed(4)} (-${config.trailingStop}%)`, 'INFO');
                log(`üéØ Raison: ${analysis.reason}`, 'INFO');
                
                updatePositionsDisplay();
                await refreshBalance();
                
                return true;
            } catch (error) {
                log(`‚ùå Erreur ouverture position ${symbol}: ${error.message}`, 'ERROR');
                return false;
            }
        }
        
        function updatePositionsDisplay() {
            const container = document.getElementById('positionsContainer');
            
            if (openPositions.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Aucune position ouverte</div>';
                return;
            }
            
            container.innerHTML = '';
            openPositions.forEach(position => {
                const item = document.createElement('div');
                item.className = 'position-item';
                
                const pnlPercent = ((position.currentPrice - position.entryPrice) / position.entryPrice * 100).toFixed(2);
                const pnlClass = pnlPercent >= 0 ? 'color: #28a745' : 'color: #dc3545';
                
                item.innerHTML = `
                    <div><strong>${position.symbol}</strong> ${position.side} - ${position.size.toFixed(2)} USDT</div>
                    <div>Entr√©e: ${position.entryPrice.toFixed(2)} | Actuel: ${position.currentPrice.toFixed(2)}</div>
                    <div>P&L: <span style="${pnlClass}">${pnlPercent}%</span> | Stop: ${position.trailingStopPrice.toFixed(2)}</div>
                `;
                
                container.appendChild(item);
            });
        }
        
        // === BOUCLE PRINCIPALE DE TRADING ===
        async function tradingLoop() {
            if (!botRunning || top20Pairs.length === 0) {
                return;
            }
            
            try {
                // Scanner une paire √† la fois
                if (currentScanIndex >= top20Pairs.length) {
                    currentScanIndex = 0;
                    // Rescan du TOP 20 toutes les 20 analyses
                    if (botStats.totalScans % 20 === 0) {
                        await scanTop20Volume();
                    }
                }
                
                const currentPair = top20Pairs[currentScanIndex];
                document.getElementById('currentScanPair').textContent = currentPair.symbol;
                
                // Analyser la paire courante avec le VRAIE MACD
                const analysis = await analyzePairMACD(currentPair.symbol);
                botStats.totalScans++;
                
                // Mettre √† jour l'affichage
                updateTop20Display();
                
                // Log d√©taill√© de l'analyse
                if (analysis.crossover) {
                    log(`üéØ ${analysis.symbol}: ${analysis.reason}`, 'SUCCESS');
                } else {
                    log(`üìä ${analysis.symbol}: ${analysis.reason}`, 'INFO');
                }
                
                // ‚úÖ CONDITION D'ENTR√âE EXACTE : Croisement haussier MACD d√©tect√©
                if (analysis.signal === 'BUY' && analysis.crossover) {
                    botStats.totalSignals++;
                    log(`üö® SIGNAL MACD HAUSSIER D√âTECT√â: ${analysis.symbol}`, 'SUCCESS');
                    log(`üìà MACD: ${analysis.macd.toFixed(4)} | Signal: ${analysis.macdSignal.toFixed(4)} | Histogram: ${analysis.histogram.toFixed(4)}`, 'SUCCESS');
                    
                    // V√©rifier si on peut ouvrir une position
                    const canOpen = !hasOpenPosition(analysis.symbol) && calculatePositionSize() >= 10;
                    
                    if (canOpen) {
                        await openPosition(analysis.symbol, analysis);
                    } else if (hasOpenPosition(analysis.symbol)) {
                        log(`‚ö†Ô∏è Position d√©j√† ouverte sur ${analysis.symbol}`, 'WARNING');
                    } else {
                        log(`‚ö†Ô∏è Capital insuffisant pour ${analysis.symbol}`, 'WARNING');
                    }
                }
                
                // Passer √† la paire suivante
                currentScanIndex++;
                
                // Mise √† jour des statistiques
                updateStats();
                
            } catch (error) {
                log(`‚ùå Erreur dans la boucle de trading: ${error.message}`, 'ERROR');
            }
        }
        
        // === GESTION DU TRAILING STOP ===
        async function updateTrailingStops() {
            if (openPositions.length === 0) return;
            
            for (let position of openPositions) {
                if (position.status !== 'OPEN') continue;
                
                try {
                    // R√©cup√©rer le prix actuel
                    const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/ticker?productType=usdt-futures&symbol=${position.symbol}`);
                    const data = await response.json();
                    
                    if (data.code === '00000' && data.data && data.data.length > 0) {
                        const currentPrice = parseFloat(data.data[0].lastPr);
                        position.currentPrice = currentPrice;
                        
                        // Mettre √† jour le plus haut prix atteint
                        if (currentPrice > position.highestPrice) {
                            position.highestPrice = currentPrice;
                            
                            // Mettre √† jour le trailing stop
                            const newStopPrice = currentPrice * (1 - config.trailingStop / 100);
                            if (newStopPrice > position.trailingStopPrice) {
                                position.trailingStopPrice = newStopPrice;
                                log(`üìà Trailing stop mis √† jour pour ${position.symbol}: ${newStopPrice.toFixed(2)}`, 'INFO');
                            }
                        }
                        
                        // V√©rifier si le trailing stop est atteint
                        if (currentPrice <= position.trailingStopPrice) {
                            await closePosition(position, 'TRAILING_STOP');
                        }
                    }
                } catch (error) {
                    log(`‚ùå Erreur mise √† jour trailing stop ${position.symbol}: ${error.message}`, 'ERROR');
                }
            }
            
            updatePositionsDisplay();
        }
        
        // === FERMETURE DE POSITION ===
        async function closePosition(position, reason) {
            try {
                position.status = 'CLOSED';
                position.closePrice = position.currentPrice;
                position.closeTime = new Date().toISOString();
                position.closeReason = reason;
                
                const pnl = ((position.closePrice - position.entryPrice) / position.entryPrice) * 100;
                const pnlColor = pnl >= 0 ? 'SUCCESS' : 'ERROR';
                
                log(`üîö Position ferm√©e: ${position.symbol} - Raison: ${reason}`, 'INFO');
                log(`üí∞ P&L: ${pnl.toFixed(2)}% | Entr√©e: ${position.entryPrice.toFixed(2)} | Sortie: ${position.closePrice.toFixed(2)}`, pnlColor);
                
                // Retirer de la liste des positions ouvertes
                openPositions = openPositions.filter(pos => pos.id !== position.id);
                
                updatePositionsDisplay();
                await refreshBalance();
                
            } catch (error) {
                log(`‚ùå Erreur fermeture position: ${error.message}`, 'ERROR');
            }
        }
        
        // === D√âMARRAGE ET ARR√äT DU BOT ===
        async function startBot() {
            // V√©rifier la connexion
            if (!config.apiKey) {
                const connected = await testConnection();
                if (!connected) {
                    alert('Veuillez d\'abord √©tablir la connexion API');
                    return;
                }
            }
            
            // R√©cup√©rer les param√®tres
            config.capitalPercent = parseFloat(document.getElementById('capitalPercent').value);
            config.leverage = parseFloat(document.getElementById('leverage').value);
            config.trailingStop = parseFloat(document.getElementById('trailingStop').value);
            
            // Valider les param√®tres
            if (config.capitalPercent < 1 || config.capitalPercent > 20) {
                alert('Le pourcentage de capital doit √™tre entre 1% et 20%');
                return;
            }
            
            // Scanner le TOP 20 initial
            const scanSuccess = await scanTop20Volume();
            if (!scanSuccess) {
                alert('Impossible de scanner le TOP 20. V√©rifiez la connexion.');
                return;
            }
            
            // D√©marrer le bot
            botRunning = true;
            botStartTime = Date.now();
            botStats = { totalScans: 0, totalSignals: 0, totalPositions: 0 };
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            log('üöÄ BOT D√âMARR√â - Strat√©gie MACD TOP 20 Volume (VRAIE MACD)', 'SUCCESS');
            log(`‚öôÔ∏è Config: ${config.capitalPercent}% capital √ó ${config.leverage}x levier √ó ${config.trailingStop}% trailing stop`, 'INFO');
            log(`üìä Timeframe: 5 minutes | Indicateur: Croisement haussier MACD`, 'INFO');
            log(`üéØ Surveillance: ${top20Pairs.length} paires TOP volume`, 'INFO');
            log(`üìà Condition: Ouvrir LONG si MACD croise au-dessus de Signal`, 'INFO');
            
            // D√©marrer les intervalles
            tradingLoopInterval = setInterval(tradingLoop, 5000); // Analyse toutes les 5 secondes (pour respecter timeframe 5min)
            volumeScanInterval = setInterval(scanTop20Volume, 300000); // Rescan TOP 20 toutes les 5 minutes
            statsInterval = setInterval(() => {
                updateStats();
                updateTrailingStops();
            }, 10000); // Stats et trailing stops toutes les 10 secondes
            
            // Premier appel imm√©diat
            tradingLoop();
        }
        
        function stopBot() {
            botRunning = false;
            
            // Arr√™ter tous les intervalles
            if (tradingLoopInterval) clearInterval(tradingLoopInterval);
            if (volumeScanInterval) clearInterval(volumeScanInterval);
            if (statsInterval) clearInterval(statsInterval);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('currentScanPair').textContent = '--';
            
            log('üõë Bot arr√™t√©', 'INFO');
            log(`üìä Session termin√©e: ${botStats.totalScans} scans, ${botStats.totalSignals} signaux`, 'INFO');
        }
        
        // === INITIALISATION ===
        window.onload = async function() {
            log('üîß Initialisation du bot MACD TOP 20...', 'INFO');
            
            // Charger automatiquement les cl√©s si disponibles
            const keysLoaded = loadKeys();
            if (keysLoaded) {
                setTimeout(testConnection, 1000);
            }
            
            // Test du proxy
            try {
                const response = await fetch(`${API_BASE}/test`);
                const data = await response.json();
                log(`‚úÖ Proxy connect√©: ${data.message || 'API accessible'}`, 'SUCCESS');
            } catch (error) {
                log(`‚ùå Erreur proxy: ${error.message}`, 'ERROR');
            }
            
            // Scan initial du TOP 20 (sans authentification)
            log('üîç Scan initial du TOP 20 sans authentification...', 'INFO');
            try {
                const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/tickers?productType=usdt-futures`);
                const data = await response.json();
                
                if (data.code === '00000' && data.data) {
                    const validPairs = data.data
                        .filter(pair => parseFloat(pair.usdtVolume || 0) > 10000000)
                        .sort((a, b) => parseFloat(b.usdtVolume) - parseFloat(a.usdtVolume))
                        .slice(0, 20);
                    
                    top20Pairs = validPairs;
                    updateTop20Display();
                    
                    log(`‚úÖ TOP 20 pr√©-charg√©: ${validPairs.length} paires disponibles`, 'SUCCESS');
                    document.getElementById('lastScanTime').textContent = new Date().toLocaleTimeString();
                }
            } catch (error) {
                log(`‚ö†Ô∏è Pr√©-chargement TOP 20 √©chou√©: ${error.message}`, 'WARNING');
            }
            
            log('‚úÖ Bot pr√™t! Configurez vos cl√©s API et cliquez sur "D√©marrer Strat√©gie"', 'SUCCESS');
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Trading Bitget Futures - Strat√©gie MACD TOP 20</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        
        .status-dot.online {
            background: #28a745;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }
        
        .btn-success {
            background: linear-gradient(45deg, #28a745, #1e7e34);
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .logs {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .balance-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #f8f9fa;
            margin-bottom: 8px;
            border-radius: 6px;
        }
        
        .price-display {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin: 10px 0;
        }
        
        .indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .indicator.buy {
            background: #28a745;
            color: white;
        }
        
        .indicator.sell {
            background: #dc3545;
            color: white;
        }
        
        .indicator.hold {
            background: #ffc107;
            color: #212529;
        }
        
        .version {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .top20-list {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
        }
        
        .pair-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            font-size: 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .pair-item:last-child {
            border-bottom: none;
        }
        
        .scanning {
            background: #ffc107;
            color: black;
        }
        
        .position-item {
            background: #e8f5e8;
            border: 1px solid #28a745;
            border-radius: 6px;
            padding: 6px;
            margin-bottom: 4px;
            font-size: 11px;
            line-height: 1.2;
        }
        
        .position-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .position-details {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        
        .trailing-status {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            display: inline-block;
        }
        
        .trailing-active {
            background: #d4edda;
            color: #155724;
        }
        
        .pnl-positive {
            color: #28a745;
            font-weight: bold;
        }
        
        .pnl-negative {
            color: #dc3545;
            font-weight: bold;
        }
        
        .pnl-neutral {
            color: #6c757d;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="version">üìÖ 02/06/2025 - TRAILING STOP CORRIG√â</div>
    
    <div class="container">
        <div class="header">
            <h1>üöÄ Bot Trading Bitget Futures</h1>
            <p>Strat√©gie MACD - TOP 20 Volume - TRAILING STOP FIX√â</p>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>‚öôÔ∏è Configuration API</h3>
                <div class="status">
                    <div class="status-dot" id="connectionStatus"></div>
                    <span id="connectionText">D√©connect√©</span>
                </div>
                
                <div class="form-group">
                    <label>API Key:</label>
                    <input type="password" id="apiKey" placeholder="Votre API Key Bitget">
                </div>
                
                <div class="form-group">
                    <label>Secret Key:</label>
                    <input type="password" id="secretKey" placeholder="Votre Secret Key">
                </div>
                
                <div class="form-group">
                    <label>Passphrase:</label>
                    <input type="password" id="passphrase" placeholder="Votre Passphrase">
                </div>
                
                <button class="btn" onclick="testConnection()">üîó Tester la connexion</button>
                <button class="btn btn-success" onclick="saveKeys()" style="margin-top: 10px;">üíæ Sauvegarder les cl√©s</button>
            </div>
            
            <div class="card">
                <h3>üìä Param√®tres Strat√©gie MACD</h3>
                
                <div class="form-group">
                    <label>Capital √† utiliser (% du total):</label>
                    <input type="number" id="capitalPercent" value="5" min="1" max="20" step="1">
                    <small>5% du capital √ó levier 2x par position</small>
                </div>
                
                <div class="form-group">
                    <label>Levier:</label>
                    <select id="leverage">
                        <option value="2" selected>2x (Recommand√©)</option>
                        <option value="3">3x</option>
                        <option value="5">5x</option>
                        <option value="10">10x</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Trailing Stop (%):</label>
                    <input type="number" id="trailingStop" value="1" min="0.5" max="5" step="0.1">
                    <small>Recul maximum autoris√©</small>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="startBot()" id="startBtn">‚ñ∂Ô∏è D√©marrer Strat√©gie</button>
                    <button class="btn btn-danger" onclick="stopBot()" id="stopBtn" disabled>‚èπÔ∏è Arr√™ter Bot</button>
                </div>
                
                <div style="margin-top: 15px;">
                    <button class="btn" onclick="scanTop20Volume()" style="width: 100%;">üîç Scanner TOP 20 Volume</button>
                </div>
                
                <div style="margin-top: 10px;">
                    <button class="btn" onclick="checkTrailingStops()" style="width: 100%;">üîç V√©rifier Trailing Stops</button>
                </div>
            </div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>üìà TOP 20 Volume (Surveillance)</h3>
                <div style="margin-bottom: 10px;">
                    <strong>Paire en cours d'analyse:</strong> <span id="currentScanPair">--</span>
                </div>
                <div class="top20-list" id="top20List">
                    <div class="pair-item">
                        <span>Chargement...</span>
                        <span>--</span>
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Derni√®re MAJ:</strong> <span id="lastScanTime">--</span>
                </div>
            </div>
            
            <div class="card">
                <h3>üíº Positions Ouvertes</h3>
                <div id="positionsContainer">
                    <div style="text-align: center; color: #666; padding: 20px;">
                        Aucune position ouverte
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <strong>Capital utilis√©:</strong> <span id="usedCapital">0 USDT</span> / 
                    <strong>Disponible:</strong> <span id="availableCapital">-- USDT</span>
                </div>
            </div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>üí≥ Balance Futures</h3>
                <div id="balanceContainer">
                    <div class="balance-item">
                        <span>USDT Total:</span>
                        <span id="usdtBalance">--</span>
                    </div>
                    <div class="balance-item">
                        <span>√âquit√©:</span>
                        <span id="totalEquity">--</span>
                    </div>
                </div>
                <button class="btn" onclick="refreshBalance()" style="width: 100%; margin-top: 10px;">üîÑ Actualiser</button>
            </div>
            
            <div class="card">
                <h3>üìä Statistiques Bot</h3>
                <div class="balance-item">
                    <span>Scans effectu√©s:</span>
                    <span id="totalScans">0</span>
                </div>
                <div class="balance-item">
                    <span>Signaux d√©tect√©s:</span>
                    <span id="totalSignals">0</span>
                </div>
                <div class="balance-item">
                    <span>Positions ouvertes:</span>
                    <span id="totalOpenPositions">0</span>
                </div>
                <div class="balance-item">
                    <span>Uptime:</span>
                    <span id="botUptime">00:00:00</span>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3>üìù Logs de Trading</h3>
            <div class="logs" id="logs">
                [INFO] Bot de trading MACD TOP 20 initialis√©...<br>
                [INFO] Strat√©gie: 5% capital √ó 2x levier √ó 1% trailing stop<br>
                [INFO] TRAILING STOP CORRIG√â - moving_plan au lieu de track_plan<br>
                [INFO] En attente de configuration API...<br>
            </div>
            <button class="btn" onclick="clearLogs()" style="margin-top: 10px;">üóëÔ∏è Effacer logs</button>
        </div>
    </div>

    <script>
        const API_BASE = 'https://api.crea-vigne.fr/api';
        let botRunning = false;
        let volumeScanInterval = null;
        let tradingLoopInterval = null;
        let statsInterval = null;
        let pnlUpdateInterval = null;
        let botStartTime = null;
        
        let top20Pairs = [];
        let currentScanIndex = 0;
        let openPositions = [];
        let botStats = {
            totalScans: 0,
            totalSignals: 0,
            totalPositions: 0
        };
        
        let config = {
            apiKey: '',
            secretKey: '',
            passphrase: '',
            capitalPercent: 5,
            leverage: 2,
            trailingStop: 1.0
        };
        
        let balance = { USDT: 0, totalEquity: 0 };
        
        function log(message, type = 'INFO') {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] [${type}] ${message}<br>`;
            
            // Ajouter le nouveau log
            logs.innerHTML += logMessage;
            
            // Limiter √† 100 logs maximum
            const logLines = logs.innerHTML.split('<br>').filter(line => line.trim() !== '');
            if (logLines.length > 100) {
                // Garder seulement les 100 derniers logs
                const recentLogs = logLines.slice(-100);
                logs.innerHTML = recentLogs.join('<br>') + '<br>';
            }
            
            logs.scrollTop = logs.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }
        
        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }
        
        function updateStats() {
            document.getElementById('totalScans').textContent = botStats.totalScans;
            document.getElementById('totalSignals').textContent = botStats.totalSignals;
            document.getElementById('totalOpenPositions').textContent = openPositions.length;
            
            if (botStartTime) {
                const elapsed = Date.now() - botStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('botUptime').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        function saveKeys() {
            const keys = {
                apiKey: document.getElementById('apiKey').value,
                secretKey: document.getElementById('secretKey').value,
                passphrase: document.getElementById('passphrase').value
            };
            
            if (keys.apiKey && keys.secretKey && keys.passphrase) {
                config.apiKey = keys.apiKey;
                config.secretKey = keys.secretKey;
                config.passphrase = keys.passphrase;
                log('üîë Cl√©s sauvegard√©es en m√©moire', 'SUCCESS');
            } else {
                log('‚ö†Ô∏è Veuillez remplir tous les champs avant de sauvegarder', 'WARNING');
            }
        }
        
        async function makeRequest(endpoint, options = {}) {
            try {
                const timestamp = Date.now().toString();
                const headers = {
                    'Content-Type': 'application/json',
                    'apikey': config.apiKey,
                    'secretkey': config.secretKey,
                    'passphrase': config.passphrase,
                    'timestamp': timestamp,
                    ...options.headers
                };
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    ...options,
                    headers
                });
                
                return await response.json();
            } catch (error) {
                log(`Erreur API: ${error.message}`, 'ERROR');
                return null;
            }
        }
        
        async function testConnection() {
            config.apiKey = document.getElementById('apiKey').value;
            config.secretKey = document.getElementById('secretKey').value;
            config.passphrase = document.getElementById('passphrase').value;
            
            if (!config.apiKey || !config.secretKey || !config.passphrase) {
                alert('Veuillez remplir tous les champs API');
                return;
            }
            
            log('üîÑ Test de connexion √† Bitget Futures...');
            
            const result = await makeRequest('/bitget/api/v2/mix/account/accounts?productType=USDT-FUTURES');
            
            if (result && result.code === '00000') {
                document.getElementById('connectionStatus').classList.add('online');
                document.getElementById('connectionText').textContent = 'Connect√© (Futures)';
                log('‚úÖ Connexion r√©ussie √† Bitget Futures!', 'SUCCESS');
                await refreshBalance();
                return true;
            } else {
                log('‚ùå √âchec de la connexion. V√©rifiez vos cl√©s API Futures.', 'ERROR');
                return false;
            }
        }
        
        async function refreshBalance() {
            const result = await makeRequest('/bitget/api/v2/mix/account/accounts?productType=USDT-FUTURES');
            
            if (result && result.data && result.data.length > 0) {
                const account = result.data[0];
                balance.USDT = parseFloat(account.available || 0);
                balance.totalEquity = parseFloat(account.usdtEquity || account.equity || 0);
                
                document.getElementById('usdtBalance').textContent = balance.USDT.toFixed(2);
                document.getElementById('totalEquity').textContent = balance.totalEquity.toFixed(2);
                
                const usedCapital = openPositions.reduce((sum, pos) => sum + pos.size, 0);
                const availableCapital = balance.totalEquity * (config.capitalPercent / 100) * config.leverage - usedCapital;
                
                document.getElementById('usedCapital').textContent = usedCapital.toFixed(2);
                document.getElementById('availableCapital').textContent = Math.max(0, availableCapital).toFixed(2);
                
                log('üí∞ Balance mise √† jour', 'INFO');
            } else {
                log('‚ö†Ô∏è Impossible de r√©cup√©rer la balance', 'WARNING');
            }
        }
        
        async function scanTop20Volume() {
            try {
                log('üîç Scan des volumes TOP 20 en cours...', 'INFO');
                
                const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/tickers?productType=usdt-futures`);
                const data = await response.json();
                
                if (data.code === '00000' && data.data) {
                    const validPairs = data.data
                        .filter(pair => {
                            const volume = parseFloat(pair.usdtVolume || 0);
                            return volume > 10000000 && pair.symbol.endsWith('USDT');
                        })
                        .sort((a, b) => parseFloat(b.usdtVolume) - parseFloat(a.usdtVolume))
                        .slice(0, 20);
                    
                    top20Pairs = validPairs;
                    currentScanIndex = 0;
                    
                    updateTop20Display();
                    
                    const totalVolume = validPairs.reduce((sum, pair) => sum + parseFloat(pair.usdtVolume), 0);
                    log(`‚úÖ TOP 20 mis √† jour: ${validPairs.length} paires, Volume total: ${formatNumber(totalVolume)}`, 'SUCCESS');
                    
                    validPairs.slice(0, 5).forEach((pair, index) => {
                        log(`#${index + 1} ${pair.symbol}: ${formatNumber(pair.usdtVolume)} vol`, 'INFO');
                    });
                    
                    document.getElementById('lastScanTime').textContent = new Date().toLocaleTimeString();
                    return true;
                } else {
                    log('‚ùå Erreur lors du scan des volumes', 'ERROR');
                    return false;
                }
            } catch (error) {
                log(`‚ùå Erreur scanner: ${error.message}`, 'ERROR');
                return false;
            }
        }
        
        function updateTop20Display() {
            const container = document.getElementById('top20List');
            container.innerHTML = '';
            
            top20Pairs.forEach((pair, index) => {
                const item = document.createElement('div');
                item.className = 'pair-item';
                if (index === currentScanIndex) {
                    item.classList.add('scanning');
                }
                
                item.innerHTML = `
                    <span>#${index + 1} ${pair.symbol}</span>
                    <span>${formatNumber(pair.usdtVolume)}</span>
                `;
                container.appendChild(item);
            });
        }
        
        async function setLeverage(symbol, leverage) {
            log(`‚ö° Configuration du levier ${leverage}x pour ${symbol}...`, 'INFO');
            
            const leverageData = {
                symbol: symbol,
                productType: "USDT-FUTURES",
                marginCoin: "USDT",
                leverage: leverage.toString()
            };
            
            const result = await makeRequest('/bitget/api/v2/mix/account/set-leverage', {
                method: 'POST',
                body: JSON.stringify(leverageData)
            });
            
            if (result && result.code === '00000') {
                log(`‚úÖ Levier ${leverage}x configur√© avec succ√®s pour ${symbol}!`, 'SUCCESS');
                return true;
            } else {
                log(`‚ö†Ô∏è √âchec config levier ${symbol}: ${result?.msg || 'Erreur'}`, 'WARNING');
                return false;
            }
        }
        
        async function getKlineData(symbol, limit = 50) {
            try {
                // S'assurer qu'on r√©cup√®re bien les donn√©es 5min
                const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/candles?symbol=${symbol}&productType=usdt-futures&granularity=5m&limit=${limit}`);
                const data = await response.json();
                
                if (data.code === '00000' && data.data) {
                    const klines = data.data.map(candle => ({
                        timestamp: parseInt(candle[0]),
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    })).reverse(); // Plus ancien au plus r√©cent
                    
                    log(`üìä ${symbol}: ${klines.length} bougies 5m r√©cup√©r√©es`, 'DEBUG');
                    return klines;
                }
            } catch (error) {
                console.error(`Erreur klines ${symbol}:`, error);
            }
            return [];
        }
        
        function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            if (prices.length < slowPeriod + signalPeriod + 5) {
                return { macd: 0, signal: 0, histogram: 0, crossover: false };
            }
            
            // Calcul EMA comme TradingView (m√©thode standard)
            function calculateEMA(data, period) {
                const multiplier = 2 / (period + 1);
                const emas = [];
                
                // Premi√®re valeur = SMA des premi√®res p√©riodes
                let sma = 0;
                for (let i = 0; i < period; i++) {
                    sma += data[i];
                }
                sma = sma / period;
                emas[period - 1] = sma;
                
                // Calcul EMA standard
                for (let i = period; i < data.length; i++) {
                    const ema = (data[i] * multiplier) + (emas[i - 1] * (1 - multiplier));
                    emas[i] = ema;
                }
                
                return emas;
            }
            
            const ema12 = calculateEMA(prices, fastPeriod);
            const ema26 = calculateEMA(prices, slowPeriod);
            
            // Ligne MACD
            const macdLine = [];
            for (let i = slowPeriod - 1; i < prices.length; i++) {
                if (ema12[i] !== undefined && ema26[i] !== undefined) {
                    macdLine.push(ema12[i] - ema26[i]);
                }
            }
            
            // Signal line (EMA 9 du MACD)
            const signalLine = calculateEMA(macdLine, signalPeriod);
            
            if (macdLine.length < 2 || signalLine.length < 2) {
                return { macd: 0, signal: 0, histogram: 0, crossover: false };
            }
            
            const currentMacd = macdLine[macdLine.length - 1];
            const previousMacd = macdLine[macdLine.length - 2];
            const currentSignal = signalLine[signalLine.length - 1];
            const previousSignal = signalLine[signalLine.length - 2];
            
            const currentHistogram = currentMacd - currentSignal;
            const previousHistogram = previousMacd - previousSignal;
            
            // Croisement haussier STRICT : 
            // - Bougie pr√©c√©dente : MACD <= Signal 
            // - Bougie actuelle : MACD > Signal
            // - ET histogram passe de n√©gatif √† positif
            const crossover = (previousHistogram <= 0) && (currentHistogram > 0) && 
                             (previousMacd <= previousSignal) && (currentMacd > currentSignal);
            
            return {
                macd: currentMacd,
                signal: currentSignal,
                histogram: currentHistogram,
                crossover: crossover,
                macdLine: macdLine,
                signalLine: signalLine
            };
        }
        
        async function analyzePairMACD(symbol) {
            try {
                const klines = await getKlineData(symbol, 100); // Plus de donn√©es pour calcul pr√©cis
                
                if (klines.length < 50) {
                    return { symbol, signal: 'HOLD', strength: 0, reason: 'Donn√©es insuffisantes' };
                }
                
                const closePrices = klines.map(k => k.close);
                const currentPrice = closePrices[closePrices.length - 1];
                const volume24h = klines.slice(-288).reduce((sum, k) => sum + k.volume, 0);
                
                const macdData = calculateMACD(closePrices);
                
                let macdSignal = 'HOLD';
                let signalStrength = 0;
                let reason = '';
                
                if (macdData.crossover && macdData.histogram > 0) {
                    macdSignal = 'BUY';
                    signalStrength = Math.abs(macdData.histogram) * 1000; // Ajuster la sensibilit√©
                    reason = `üî• CROISEMENT HAUSSIER CONFIRM√â! MACD: ${macdData.macd.toFixed(6)} > Signal: ${macdData.signal.toFixed(6)} | Histogram: ${macdData.histogram.toFixed(6)}`;
                } else if (macdData.macd > macdData.signal) {
                    reason = `üìà MACD au-dessus Signal mais pas de croisement r√©cent. MACD: ${macdData.macd.toFixed(6)}, Signal: ${macdData.signal.toFixed(6)}`;
                } else {
                    reason = `üìä MACD en dessous Signal. MACD: ${macdData.macd.toFixed(6)}, Signal: ${macdData.signal.toFixed(6)}`;
                }
                
                return {
                    symbol,
                    signal: macdSignal,
                    strength: signalStrength,
                    price: currentPrice,
                    volume24h: volume24h,
                    macd: macdData.macd,
                    macdSignal: macdData.signal,
                    histogram: macdData.histogram,
                    crossover: macdData.crossover,
                    reason: reason
                };
                
            } catch (error) {
                log(`‚ùå ERREUR ANALYSE ${symbol}: ${error.message}`, 'ERROR');
                console.error(`Erreur analyse MACD ${symbol}:`, error);
                return { symbol, signal: 'HOLD', strength: 0, reason: `Erreur: ${error.message}` };
            }
        }
        
        function calculatePositionSize() {
            const maxPositionValue = (balance.totalEquity * config.capitalPercent / 100) * config.leverage;
            return Math.max(maxPositionValue, 10);
        }
        
        function hasOpenPosition(symbol) {
            return openPositions.some(pos => pos.symbol === symbol && pos.status === 'OPEN');
        }
        
        // FONCTION CORRIG√âE POUR TRAILING STOP
        async function openPosition(symbol, analysis) {
            if (hasOpenPosition(symbol)) {
                return false;
            }
            
            const positionValue = calculatePositionSize();
            if (positionValue < 10) {
                log(`‚ö†Ô∏è Capital insuffisant pour ouvrir position sur ${symbol}`, 'WARNING');
                return false;
            }
            
            try {
                // 1. CONFIGURER LE LEVIER
                await setLeverage(symbol, config.leverage);
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // 2. CALCULER LA QUANTIT√â
                const quantity = (positionValue / analysis.price).toFixed(6);
                
                log(`üîÑ Ouverture position LONG ${symbol}...`, 'INFO');
                log(`üí∞ Prix: ${analysis.price} | Quantit√©: ${quantity} | Valeur: ${positionValue.toFixed(2)} USDT`, 'INFO');
                
                // 3. ORDRE D'ACHAT MARKET
                const orderData = {
                    symbol: symbol,
                    productType: "USDT-FUTURES",
                    marginMode: "isolated",
                    marginCoin: "USDT",
                    size: quantity,
                    side: "buy",
                    tradeSide: "open",
                    orderType: "market",
                    clientOid: `${Date.now()}_${symbol}`
                };
                
                const orderResult = await makeRequest('/bitget/api/v2/mix/order/place-order', {
                    method: 'POST',
                    body: JSON.stringify(orderData)
                });
                
                if (!orderResult || orderResult.code !== '00000') {
                    log(`‚ùå √âchec ouverture position ${symbol}: ${orderResult?.msg || 'Erreur inconnue'}`, 'ERROR');
                    return false;
                }
                
                log(`‚úÖ Position ouverte: ${symbol} - Ordre ID: ${orderResult.data.orderId}`, 'SUCCESS');
                
                // 4. ATTENDRE QUE LA POSITION SOIT REMPLIE
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // 5. TRAILING STOP CORRIG√â
                const trailingStopData = {
                    planType: "moving_plan",  // ‚úÖ CORRIG√â : moving_plan pour trailing stop
                    symbol: symbol,
                    productType: "USDT-FUTURES",
                    marginMode: "isolated",
                    marginCoin: "USDT",
                    size: quantity,
                    rangeRate: config.trailingStop.toString(),  // ‚úÖ rangeRate au lieu de callbackRatio
                    side: "sell",
                    tradeSide: "close",
                    orderType: "market",
                    clientOid: `trail_${Date.now()}_${symbol}`,
                    reduceOnly: "YES"
                    // ‚úÖ PAS de triggerPrice pour trailing stop !
                };
                
                log(`üîÑ Configuration trailing stop ${config.trailingStop}% pour ${symbol}...`, 'INFO');
                const trailingResult = await makeRequest('/bitget/api/v2/mix/order/place-plan-order', {
                    method: 'POST',
                    body: JSON.stringify(trailingStopData)
                });
                
                if (trailingResult && trailingResult.code === '00000') {
                    log(`‚úÖ Trailing Stop moving_plan cr√©√©: ${symbol} - ${config.trailingStop}% range`, 'SUCCESS');
                    log(`üÜî Trailing Stop ID: ${trailingResult.data.orderId}`, 'INFO');
                } else {
                    log(`‚ùå √âCHEC trailing stop ${symbol}: ${trailingResult?.msg || 'Erreur API'}`, 'ERROR');
                    log(`üìã D√©tails erreur: ${JSON.stringify(trailingResult)}`, 'ERROR');
                }
                
                // 6. ENREGISTRER LA POSITION
                const position = {
                    id: Date.now(),
                    symbol: symbol,
                    side: 'LONG',
                    size: positionValue,
                    quantity: quantity,
                    entryPrice: analysis.price,
                    status: 'OPEN',
                    timestamp: new Date().toISOString(),
                    orderId: orderResult.data.orderId,
                    trailingStopId: trailingResult?.data?.orderId || null,
                    reason: analysis.reason
                };
                
                openPositions.push(position);
                botStats.totalPositions++;
                
                log(`üöÄ Position compl√®te: ${symbol} LONG ${positionValue.toFixed(2)} USDT @ ${analysis.price.toFixed(4)}`, 'SUCCESS');
                log(`üéØ Raison: ${analysis.reason}`, 'INFO');
                
                if (trailingResult?.data?.orderId) {
                    log(`üîí Trailing Stop actif (moving_plan) √† ${config.trailingStop}%`, 'SUCCESS');
                } else {
                    log(`‚ö†Ô∏è Position ouverte SANS trailing stop - Surveillance manuelle n√©cessaire`, 'WARNING');
                }
                
                updatePositionsDisplay();
                await refreshBalance();
                
                return true;
            } catch (error) {
                log(`‚ùå Erreur ouverture position ${symbol}: ${error.message}`, 'ERROR');
                return false;
            }
        }
        
        // DIAGNOSTIC AVANC√â DES TRAILING STOPS
        async function checkTrailingStops() {
            try {
                log('üîç Diagnostic complet des trailing stops...', 'INFO');
                
                // V√©rifier tous les types d'ordres conditionnels
                const planTypes = ['moving_plan', 'track_plan', 'normal_plan'];
                let totalFound = 0;
                
                for (const planType of planTypes) {
                    const result = await makeRequest(`/bitget/api/v2/mix/order/orders-plan-pending?productType=USDT-FUTURES&planType=${planType}`);
                    
                    if (result && result.code === '00000' && result.data && result.data.length > 0) {
                        log(`üìã ${planType}: ${result.data.length} ordre(s) trouv√©(s)`, 'INFO');
                        result.data.forEach(order => {
                            log(`   ‚Ä¢ ${order.symbol}: ${planType} - ID: ${order.orderId}`, 'INFO');
                        });
                        totalFound += result.data.length;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                if (totalFound === 0) {
                    log('‚ùå ALERTE: Aucun ordre conditionnel trouv√© pour vos positions!', 'ERROR');
                    log('üí° Utilisez "Stop Loss Urgence" pour prot√©ger vos positions', 'WARNING');
                } else {
                    log(`‚úÖ Total: ${totalFound} ordre(s) conditionnel(s) actif(s)`, 'SUCCESS');
                }
                
                return totalFound;
            } catch (error) {
                log(`‚ö†Ô∏è Erreur diagnostic: ${error.message}`, 'WARNING');
                return 0;
            }
        }
        
        // FONCTION POUR R√âCUP√âRER LES PNL DES POSITIONS
        async function updatePositionsPnL() {
            if (openPositions.length === 0) return;
            
            try {
                // R√©cup√©rer les positions actuelles depuis l'API
                const result = await makeRequest('/bitget/api/v2/mix/position/all-position?productType=USDT-FUTURES');
                
                if (result && result.code === '00000' && result.data) {
                    const apiPositions = result.data.filter(pos => parseFloat(pos.total) > 0);
                    
                    // Mettre √† jour les PnL dans nos positions locales
                    openPositions.forEach(localPos => {
                        const apiPos = apiPositions.find(pos => pos.symbol === localPos.symbol);
                        if (apiPos) {
                            localPos.currentPrice = parseFloat(apiPos.markPrice);
                            localPos.unrealizedPnL = parseFloat(apiPos.unrealizedPL || 0);
                            localPos.pnlPercentage = ((localPos.currentPrice - localPos.entryPrice) / localPos.entryPrice) * 100;
                        }
                    });
                    
                    updatePositionsDisplay();
                }
            } catch (error) {
                // Mise √† jour silencieuse, pas de log d'erreur pour √©viter le spam
            }
        }
        
        function updatePositionsDisplay() {
            const container = document.getElementById('positionsContainer');
            
            if (openPositions.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 15px; font-size: 12px;">Aucune position ouverte</div>';
                return;
            }
            
            container.innerHTML = '';
            openPositions.forEach(position => {
                const item = document.createElement('div');
                item.className = 'position-item';
                
                const timeAgo = Math.floor((Date.now() - new Date(position.timestamp).getTime()) / 60000);
                const hasTrailing = position.trailingStopId ? true : false;
                
                // Calcul du PnL
                let pnlDisplay = '';
                let pnlClass = 'pnl-neutral';
                
                if (position.currentPrice && position.unrealizedPnL !== undefined) {
                    const pnlValue = position.unrealizedPnL;
                    const pnlPercent = position.pnlPercentage || 0;
                    
                    if (pnlValue > 0) {
                        pnlClass = 'pnl-positive';
                        pnlDisplay = `+${pnlValue.toFixed(2)} USDT (+${pnlPercent.toFixed(2)}%)`;
                    } else if (pnlValue < 0) {
                        pnlClass = 'pnl-negative';
                        pnlDisplay = `${pnlValue.toFixed(2)} USDT (${pnlPercent.toFixed(2)}%)`;
                    } else {
                        pnlDisplay = `0.00 USDT (0.00%)`;
                    }
                } else {
                    pnlDisplay = 'Calcul...';
                }
                
                item.innerHTML = `
                    <div class="position-header">
                        <span><strong>${position.symbol}</strong> ${position.side}</span>
                        <span class="${pnlClass}">${pnlDisplay}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 2px 0;">
                        <span style="font-size: 10px;">
                            Entry: ${position.entryPrice.toFixed(4)} | 
                            Current: ${position.currentPrice ? position.currentPrice.toFixed(4) : '--'}
                        </span>
                        <span class="trailing-status ${hasTrailing ? 'trailing-active' : 'trailing-inactive'}">
                            ${hasTrailing ? `üîí TS ${config.trailingStop}%` : '‚ùå NO TS'}
                        </span>
                    </div>
                    <div class="position-details">
                        Size: ${position.size.toFixed(2)} USDT | ${timeAgo}min ago | ID: ${(position.orderId || 'N/A').slice(-8)}
                    </div>
                `;
                
                container.appendChild(item);
            });
        }
        
        async function checkPositionsStatus() {
            if (openPositions.length === 0) return;
            
            try {
                const result = await makeRequest('/bitget/api/v2/mix/position/all-position?productType=USDT-FUTURES');
                
                if (result && result.code === '00000' && result.data) {
                    const apiPositions = result.data;
                    const currentSymbols = apiPositions.filter(pos => parseFloat(pos.total) > 0).map(pos => pos.symbol);
                    
                    const closedPositions = openPositions.filter(localPos => 
                        !currentSymbols.includes(localPos.symbol)
                    );
                    
                    for (const closedPos of closedPositions) {
                        log(`üîö Position ferm√©e d√©tect√©e: ${closedPos.symbol} (Trailing Stop moving_plan)`, 'SUCCESS');
                        log(`üí∞ Position ${closedPos.symbol} ferm√©e par trailing stop √† ${config.trailingStop}%`, 'SUCCESS');
                        
                        openPositions = openPositions.filter(pos => pos.id !== closedPos.id);
                    }
                    
                    if (closedPositions.length > 0) {
                        updatePositionsDisplay();
                        await refreshBalance();
                        log(`üìä ${closedPositions.length} position(s) ferm√©e(s) - Analyse reprendra sur ces paires`, 'INFO');
                    }
                }
            } catch (error) {
                log(`‚ö†Ô∏è Erreur v√©rification positions: ${error.message}`, 'WARNING');
            }
        }
        
        async function tradingLoop() {
            if (!botRunning || top20Pairs.length === 0) {
                return;
            }
            
            try {
                log('üîç D√©but du cycle d\'analyse compl√®te des TOP 20...', 'INFO');
                
                const allAnalyses = [];
                const signalsDetected = [];
                let excludedPairs = [];
                
                for (let i = 0; i < top20Pairs.length; i++) {
                    const pair = top20Pairs[i];
                    
                    if (hasOpenPosition(pair.symbol)) {
                        excludedPairs.push(pair.symbol);
                        continue;
                    }
                    
                    document.getElementById('currentScanPair').textContent = `${pair.symbol} (${i + 1}/20)`;
                    currentScanIndex = i;
                    updateTop20Display();
                    
                    const analysis = await analyzePairMACD(pair.symbol);
                    allAnalyses.push(analysis);
                    botStats.totalScans++;
                    
                    if (analysis.crossover) {
                        log(`üéØ ${analysis.symbol}: ${analysis.reason}`, 'SUCCESS');
                    } else {
                        log(`üìä ${analysis.symbol}: ${analysis.reason}`, 'INFO');
                    }
                    
                    if (analysis.signal === 'BUY' && analysis.crossover) {
                        signalsDetected.push(analysis);
                        log(`üö® CROISEMENT MACD HAUSSIER D√âTECT√â: ${analysis.symbol}`, 'SUCCESS');
                        log(`üìà MACD: ${analysis.macd.toFixed(4)} | Signal: ${analysis.macdSignal.toFixed(4)} | Histogram: ${analysis.histogram.toFixed(4)}`, 'SUCCESS');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                if (excludedPairs.length > 0) {
                    log(`üö´ ${excludedPairs.length} paires exclues (positions ouvertes): ${excludedPairs.join(', ')}`, 'INFO');
                }
                
                log(`üìä Cycle termin√©: ${allAnalyses.length} paires analys√©es, ${signalsDetected.length} signaux MACD d√©tect√©s`, 'INFO');
                
                if (signalsDetected.length > 0) {
                    botStats.totalSignals += signalsDetected.length;
                    
                    log(`üéØ ${signalsDetected.length} croisement(s) haussier(s) MACD d√©tect√©(s):`, 'SUCCESS');
                    signalsDetected.forEach(signal => {
                        log(`   ‚Ä¢ ${signal.symbol}: MACD ${signal.macd.toFixed(4)} > Signal ${signal.macdSignal.toFixed(4)}`, 'SUCCESS');
                    });
                    
                    for (const signal of signalsDetected) {
                        const canOpen = !hasOpenPosition(signal.symbol) && calculatePositionSize() >= 10;
                        
                        if (canOpen) {
                            await openPosition(signal.symbol, signal);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } else if (hasOpenPosition(signal.symbol)) {
                            log(`‚ö†Ô∏è Position d√©j√† ouverte sur ${signal.symbol}`, 'WARNING');
                        } else {
                            log(`‚ö†Ô∏è Capital insuffisant pour ${signal.symbol}`, 'WARNING');
                        }
                    }
                } else {
                    log('üìä Aucun croisement haussier MACD d√©tect√© sur les paires disponibles', 'INFO');
                }
                
                document.getElementById('currentScanPair').textContent = `Cycle termin√© - ${openPositions.length} positions actives`;
                updateStats();
                
            } catch (error) {
                log(`‚ùå Erreur dans la boucle de trading: ${error.message}`, 'ERROR');
            }
        }
        
        async function startBot() {
            if (!config.apiKey) {
                const connected = await testConnection();
                if (!connected) {
                    alert('Veuillez d\'abord √©tablir la connexion API');
                    return;
                }
            }
            
            config.capitalPercent = parseFloat(document.getElementById('capitalPercent').value);
            config.leverage = parseFloat(document.getElementById('leverage').value);
            config.trailingStop = parseFloat(document.getElementById('trailingStop').value);
            
            if (config.capitalPercent < 1 || config.capitalPercent > 20) {
                alert('Le pourcentage de capital doit √™tre entre 1% et 20%');
                return;
            }
            
            const scanSuccess = await scanTop20Volume();
            if (!scanSuccess) {
                alert('Impossible de scanner le TOP 20. V√©rifiez la connexion.');
                return;
            }
            
            botRunning = true;
            botStartTime = Date.now();
            botStats = { totalScans: 0, totalSignals: 0, totalPositions: 0 };
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            log('üöÄ BOT D√âMARR√â - Strat√©gie MACD TOP 20 avec TRAILING STOP CORRIG√â', 'SUCCESS');
            log(`‚öôÔ∏è Config: ${config.capitalPercent}% capital √ó ${config.leverage}x levier √ó ${config.trailingStop}% trailing stop`, 'INFO');
            log(`üìä Timeframe: 5 minutes | Indicateur: Croisement haussier MACD`, 'INFO');
            log(`üéØ Surveillance: ${top20Pairs.length} paires TOP volume (exclusion auto des positions ouvertes)`, 'INFO');
            log(`üìà Condition: Ouvrir LONG si MACD croise au-dessus de Signal`, 'INFO');
            log(`üîí Trailing Stop: moving_plan avec rangeRate (API corrig√©e)`, 'SUCCESS');
            
            tradingLoopInterval = setInterval(tradingLoop, 60000);
            volumeScanInterval = setInterval(scanTop20Volume, 300000);
            statsInterval = setInterval(() => {
                updateStats();
                checkPositionsStatus();
                updatePositionsPnL(); // Mise √† jour PnL toutes les 15 secondes
            }, 15000);
            
            // Intervalle d√©di√© pour les PnL (toutes les 10 secondes)
            pnlUpdateInterval = setInterval(updatePositionsPnL, 10000);
            
            tradingLoop();
        }
        
        function stopBot() {
            botRunning = false;
            
            if (tradingLoopInterval) clearInterval(tradingLoopInterval);
            if (volumeScanInterval) clearInterval(volumeScanInterval);
            if (statsInterval) clearInterval(statsInterval);
            if (pnlUpdateInterval) clearInterval(pnlUpdateInterval);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('currentScanPair').textContent = '--';
            
            log('üõë Bot arr√™t√©', 'INFO');
            log(`üìä Session termin√©e: ${botStats.totalScans} scans, ${botStats.totalSignals} signaux`, 'INFO');
        }
        
        window.onload = async function() {
            log('üîß Initialisation du bot MACD TOP 20 (TRAILING STOP CORRIG√â)...', 'INFO');
            
            try {
                const response = await fetch(`${API_BASE}/test`);
                const data = await response.json();
                log(`‚úÖ Proxy connect√©: ${data.message || 'API accessible'}`, 'SUCCESS');
            } catch (error) {
                log(`‚ùå Erreur proxy: ${error.message}`, 'ERROR');
            }
            
            log('üîç Pr√©-chargement du TOP 20 sans authentification...', 'INFO');
            try {
                const response = await fetch(`${API_BASE}/bitget/api/v2/mix/market/tickers?productType=usdt-futures`);
                const data = await response.json();
                
                if (data.code === '00000' && data.data) {
                    const validPairs = data.data
                        .filter(pair => parseFloat(pair.usdtVolume || 0) > 10000000)
                        .sort((a, b) => parseFloat(b.usdtVolume) - parseFloat(a.usdtVolume))
                        .slice(0, 20);
                    
                    top20Pairs = validPairs;
                    updateTop20Display();
                    
                    log(`‚úÖ TOP 20 pr√©-charg√©: ${validPairs.length} paires disponibles`, 'SUCCESS');
                    document.getElementById('lastScanTime').textContent = new Date().toLocaleTimeString();
                }
            } catch (error) {
                log(`‚ö†Ô∏è Pr√©-chargement TOP 20 √©chou√©: ${error.message}`, 'WARNING');
            }
            
            log('‚úÖ Bot pr√™t! Trailing Stop corrig√© avec moving_plan + rangeRate', 'SUCCESS');
            log('üí° Cliquez sur "V√©rifier Trailing Stops" pour voir les ordres actifs', 'INFO');
        };
    </script>
</body>
</html>

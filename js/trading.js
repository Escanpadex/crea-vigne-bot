// Trading Functions - MACD Strategy & Position Management
console.log('üìÅ Loading trading.js...');
console.log('Assuming utils.js is loaded: using shared MACD functions');

// üéØ NOUVELLE STRAT√âGIE: Limite de positions simultan√©es (2 trades maximum)
const MAX_SIMULTANEOUS_POSITIONS = 2;

// üÜï NOUVELLE FONCTION: Wrapper de retry pour les appels API
async function makeRequestWithRetry(endpoint, options, maxRetries = 3) {
    let lastError = null;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const result = await makeRequest(endpoint, options);
            return result;
        } catch (error) {
            lastError = error;
            
            if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt - 1) * 1000; // Exponential backoff
                log(`‚ö†Ô∏è Tentative ${attempt}/${maxRetries} √©chou√©e pour ${endpoint} - R√©essai dans ${delay}ms`, 'WARNING');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    
    log(`‚ùå √âchec apr√®s ${maxRetries} tentatives pour ${endpoint}: ${lastError?.message || 'Erreur inconnue'}`, 'ERROR');
    throw lastError;
}

// üéØ NOUVELLE STRAT√âGIE: Variables globales pour la nouvelle strat√©gie
let positivePairs = []; // Paires avec √©volution positive 24h
let lastPairAnalysis = 0; // Timestamp de la derni√®re analyse des paires
let positionCooldowns = new Map(); // Cooldowns apr√®s fermeture de position (1 minute)
let tradedPairsCooldown = new Map(); // Cooldowns paires trad√©es (12 heures)

// üÜï NOUVELLE FONCTION: R√©cup√©rer les paires avec √©volution positive sur 24h
async function getPositivePairs() {
    try {
        log('üîç R√©cup√©ration des paires avec √©volution positive 24h...', 'INFO');
        
        const result = await makeRequest('/bitget/api/v2/spot/market/tickers?symbol=USDT');
        
        if (!result || result.code !== '00000' || !result.data) {
            log('‚ùå Erreur r√©cup√©ration des tickers', 'ERROR');
            return [];
        }
        
        const tickers = result.data;
        const positive24hPairs = tickers
            .filter(ticker => {
                const change24h = parseFloat(ticker.changeUtc24h || 0);
                const volume = parseFloat(ticker.quoteVolume || 0);
                
                // Filtrer: √©volution positive + volume minimum pour √©viter les paires illiquides
                return change24h > 0 && volume > 100000 && ticker.symbol.endsWith('USDT');
            })
            .map(ticker => ({
                symbol: ticker.symbol.replace('USDT', 'USDT'), // Format pour futures
                change24h: parseFloat(ticker.changeUtc24h),
                volume24h: parseFloat(ticker.quoteVolume),
                price: parseFloat(ticker.close)
            }))
            .sort((a, b) => b.change24h - a.change24h); // Trier par performance d√©croissante
        
        log(`‚úÖ ${positive24hPairs.length} paires positives trouv√©es sur 24h`, 'SUCCESS');
        
        // Log des 10 meilleures paires
        if (positive24hPairs.length > 0) {
            log(`üî• Top 10 paires positives:`, 'INFO');
            positive24hPairs.slice(0, 10).forEach((pair, index) => {
                log(`   ${index + 1}. ${pair.symbol}: +${pair.change24h.toFixed(2)}% (Vol: ${formatNumber(pair.volume24h)})`, 'INFO');
            });
        }
        
        return positive24hPairs;
        
    } catch (error) {
        log(`‚ùå Erreur r√©cup√©ration paires positives: ${error.message}`, 'ERROR');
        return [];
    }
}

// üÜï NOUVELLE FONCTION: S√©lectionner une paire al√©atoire parmi les positives
function selectRandomPositivePair(excludeSymbols = []) {
    // üéØ AM√âLIORATION: V√©rifier d'abord si on a des emplacements disponibles
    const availableSlots = MAX_SIMULTANEOUS_POSITIONS - openPositions.length;
    if (availableSlots <= 0) {
        log(`‚ö†Ô∏è Aucun emplacement disponible (${openPositions.length}/${MAX_SIMULTANEOUS_POSITIONS}) - Pas de s√©lection`, 'INFO');
        return null;
    }
    
    const availablePairs = positivePairs.filter(pair => 
        !excludeSymbols.includes(pair.symbol) && 
        !hasOpenPosition(pair.symbol) &&
        !isPairInCooldown(pair.symbol) &&
        !isTradedPairInCooldown(pair.symbol) // üÜï Cooldown 12h pour paires d√©j√† trad√©es
    );
    
    if (availablePairs.length === 0) {
        log('‚ö†Ô∏è Aucune paire positive disponible pour trading (cooldowns actifs)', 'WARNING');
        return null;
    }
    
    // S√©lection al√©atoire pond√©r√©e par la performance 24h
    const randomIndex = Math.floor(Math.random() * Math.min(availablePairs.length, 20)); // Top 20 pour plus de diversit√©
    const selectedPair = availablePairs[randomIndex];
    
    log(`üé≤ Paire s√©lectionn√©e: ${selectedPair.symbol} (+${selectedPair.change24h.toFixed(2)}% sur 24h) - ${availableSlots} emplacements disponibles`, 'SUCCESS');
    
    return selectedPair;
}

// REMOVED: analyzeMultiTimeframeImproved function - replaced by new positive pairs strategy
async function analyzeMultiTimeframeImproved(symbol) {
    try {
        console.log(`üîç [TRADING] Analyse multi-timeframe am√©lior√©e pour ${symbol}`);
        
        // LOGIQUE AM√âLIOR√âE : 4H et 1H utilisent des donn√©es √©tendues, 15M utilise des donn√©es standard
        const timeframes = ['4h', '1h', '15m'];
        const results = {};
        
        for (const tf of timeframes) {
            let analysis;
            
            if (tf === '4h' || tf === '1h') {
                // üéØ AM√âLIORATION: Pour 4H et 1H, utiliser des donn√©es √©tendues (60 jours)
                // pour trouver le dernier signal valide, pas forc√©ment r√©cent
                console.log(`üìä [TRADING] ${tf}: R√©cup√©ration de donn√©es √©tendues...`);
                
                // Utiliser des donn√©es √©tendues pour avoir le dernier √©tat valide
                let extendedData = await getExtendedHistoricalDataForTrading(symbol, tf, 60);
                
                if (extendedData.length === 0) {
                    console.error(`‚ùå [TRADING] Aucune donn√©e √©tendue pour ${symbol} ${tf}`);
                    results[tf] = { symbol, timeframe: tf, signal: 'INSUFFICIENT_DATA' };
                    continue;
                }
                
                // NEW: Fallback if still insufficient after fetch
                const macdParams = getMACDParameters(tf);
                const minRequired = macdParams.slow + macdParams.signal + 10;
                if (extendedData.length < minRequired) {
                    log(`‚ö†Ô∏è Donn√©es √©tendues insuffisantes pour ${symbol} ${tf} (${extendedData.length}/${minRequired}) - Tentative d'agr√©gation depuis 15m`, 'WARNING');
                    extendedData = await aggregateDataFromLowerTimeframe(symbol, '15m', tf);
                    // If aggregation fails, set to INSUFFICIENT_DATA as before
                    if (extendedData.length < minRequired) {
                        console.error(`‚ùå [TRADING] Agr√©gation √©chou√©e pour ${symbol} ${tf} - INSUFFICIENT_DATA`);
                        results[tf] = { symbol, timeframe: tf, signal: 'INSUFFICIENT_DATA' };
                        continue;
                    } else {
                        console.log(`‚úÖ [TRADING] Agr√©gation r√©ussie pour ${symbol} ${tf} - ${extendedData.length} bougies disponibles`);
                    }
                }
                
                // Analyser avec les donn√©es √©tendues pour avoir le dernier √©tat
                analysis = await analyzePairMACDWithData(symbol, tf, extendedData);
                console.log(`üìä [TRADING] ${tf}: Signal = ${analysis.signal} (donn√©es √©tendues)`);
                
            } else {
                // üéØ Pour 15M, utiliser l'analyse standard (donn√©es r√©centes)
                console.log(`üìä [TRADING] ${tf}: Analyse standard...`);
                analysis = await analyzePairMACD(symbol, tf);
                console.log(`üìä [TRADING] ${tf}: Signal = ${analysis.signal} (donn√©es standard)`);
            }
            
            results[tf] = analysis;
            
            // Filtrage progressif: H4 et H1 doivent √™tre haussiers (dernier √©tat)
            if ((tf === '4h' || tf === '1h') && analysis.signal !== 'BULLISH' && analysis.signal !== 'BUY') {
                results.filtered = tf;
                results.filterReason = `Filtr√© au ${tf}: dernier signal ${analysis.signal}`;
                console.log(`‚ùå [TRADING] Filtr√© au ${tf}: ${analysis.signal} - ${analysis.reason}`);
                break;
            }
        }
        
        if (!results.filtered) {
            // Si H4 et H1 sont haussiers, v√©rifier le signal 15M
            const signal15m = results['15m'];
            if (signal15m.signal === 'BUY' && signal15m.crossover) {
                results.finalDecision = 'BUY';
                results.finalReason = 'H4 et H1 haussiers (donn√©es √©tendues) + croisement 15M d√©tect√©';
                console.log(`‚úÖ [TRADING] Signal BUY valid√©: ${results.finalReason}`);
            } else if (signal15m.signal === 'BULLISH') {
                results.finalDecision = 'WAIT';
                results.finalReason = 'H4 et H1 haussiers (donn√©es √©tendues), 15M haussier mais pas de croisement';
                console.log(`‚è≥ [TRADING] Signal WAIT: ${results.finalReason}`);
            } else {
                results.finalDecision = 'FILTERED';
                results.filterReason = 'Filtr√© au 15M: signal non haussier';
                console.log(`‚ùå [TRADING] Filtr√© au 15M: ${signal15m.signal}`);
            }
        } else {
            results.finalDecision = 'FILTERED';
        }
        
        return results;
        
    } catch (error) {
        console.error(`‚ùå [TRADING] Erreur analyse multi-timeframe am√©lior√©e ${symbol}:`, error);
        log(`‚ùå Erreur analyse multi-timeframe am√©lior√©e ${symbol}: ${error.message}`, 'ERROR');
        return { symbol, error: error.message };
    }
}

// üÜï FONCTION UTILITAIRE: Analyser MACD avec des donn√©es fournies
async function analyzePairMACDWithData(symbol, timeframe, klineData) {
    try {
        // üéØ R√©cup√©rer les param√®tres MACD sp√©cifiques au timeframe
        const macdParams = getMACDParameters(timeframe);
        
        // V√©rifier si on a assez de donn√©es pour l'analyse MACD
        const minRequired = macdParams.slow + macdParams.signal + 10;
        if (klineData.length < minRequired) {
            return { 
                symbol, 
                signal: 'INSUFFICIENT_DATA', 
                strength: 0, 
                reason: `Donn√©es insuffisantes: ${klineData.length}/${minRequired} bougies (MACD ${macdParams.fast},${macdParams.slow},${macdParams.signal})`, 
                timeframe 
            };
        }
        
        const closePrices = klineData.map(k => k.close);
        const currentPrice = closePrices[closePrices.length - 1];
        const volume24h = klineData.slice(-Math.min(288, klineData.length)).reduce((sum, k) => sum + k.volume, 0);
        
        // üéØ Calculer MACD avec les param√®tres sp√©cifiques au timeframe
        const macdData = calculateMACD(closePrices, macdParams.fast, macdParams.slow, macdParams.signal);
        
        let macdSignal = 'HOLD';
        let signalStrength = 0;
        let reason = `‚è≥ Calcul MACD en cours... Donn√©es insuffisantes pour ${symbol} (${timeframe}) (candles: ${klineData.length})`;
        
        if (macdData.macd != null && macdData.signal != null && macdData.histogram != null && 
            !isNaN(macdData.macd) && !isNaN(macdData.signal) && !isNaN(macdData.histogram)) {
            const crossover = macdData.previousMacd != null && macdData.previousSignal != null && 
                             macdData.previousMacd <= macdData.previousSignal && macdData.macd > macdData.signal;
            const histogramImproving = macdData.previousHistogram != null && macdData.previousHistogram2 != null && 
                                      macdData.histogram > macdData.previousHistogram && macdData.previousHistogram > macdData.previousHistogram2;
            
            if (crossover && macdData.histogram > 0 && histogramImproving) {
                macdSignal = 'BUY';
                signalStrength = 90;
                reason = `Croisement MACD + Histogram>0 + Tendance IMPROVING (${timeframe})`;
            } else if (macdData.macd > macdData.signal && macdData.histogram > 0 && histogramImproving) {
                macdSignal = 'BULLISH';
                signalStrength = 75;
                reason = `MACD>Signal + Histogram>0 + Tendance IMPROVING (${timeframe})`;
            } else if (macdData.macd > macdData.signal && macdData.histogram > 0) {
                macdSignal = 'BULLISH';
                signalStrength = 60;
                reason = `MACD>Signal + Histogram>0 (${timeframe})`;
            } else if (macdData.macd < macdData.signal) {
                macdSignal = 'BEARISH';
                signalStrength = 30;
                reason = `MACD<Signal (${timeframe})`;
            } else {
                macdSignal = 'NEUTRAL';
                signalStrength = 50;
                reason = `MACD neutre (${timeframe})`;
            }
        } else {
            // üéØ Cas o√π les donn√©es MACD sont nulles/invalides
            macdSignal = 'INSUFFICIENT_DATA';
            signalStrength = 0;
            reason = `‚ùå Donn√©es MACD invalides pour ${symbol} (${timeframe}) - MACD: ${macdData.macd}, Signal: ${macdData.signal}, Histogram: ${macdData.histogram}`;
        }
        
        return {
            symbol,
            timeframe,
            signal: macdSignal,
            strength: signalStrength,
            price: currentPrice,
            volume24h: volume24h,
            macd: macdData.macd,
            macdSignal: macdData.signal,
            histogram: macdData.histogram,
            crossover: macdData.crossover,
            reason: reason
        };
        
    } catch (error) {
        console.error(`‚ùå [TRADING] Erreur analyse MACD avec donn√©es ${symbol} ${timeframe}:`, error);
        log(`‚ùå ERREUR ANALYSE MACD ${symbol} (${timeframe}): ${error.message}`, 'ERROR');
        return { symbol, timeframe, signal: 'HOLD', strength: 0, reason: `Erreur: ${error.message}` };
    }
}

// üÜï NOUVELLE FONCTION: R√©cup√©rer des donn√©es historiques √©tendues pour 4H et 1H
async function getExtendedHistoricalDataForTrading(symbol, timeframe, days = 60) {
    try {
        console.log(`üîç [TRADING] R√©cup√©ration de donn√©es √©tendues: ${symbol} ${timeframe} sur ${days} jours`);
        
        // Utiliser la fonction existante getKlineData avec une limite √©lev√©e
        // Pour 4H sur 60 jours = 60*24/4 = 360 bougies max
        // Pour 1H sur 60 jours = 60*24 = 1440 bougies max (limit√© √† 1000 par l'API)
        const maxCandles = timeframe === '4h' ? 360 : 1000;
        
        const extendedData = await getKlineData(symbol, maxCandles, timeframe);
        
        console.log(`‚úÖ [TRADING] ${extendedData.length} bougies ${timeframe} r√©cup√©r√©es sur ${days} jours`);
        
        return extendedData;
        
    } catch (error) {
        console.error(`‚ùå [TRADING] Erreur r√©cup√©ration donn√©es √©tendues ${symbol} ${timeframe}:`, error);
        log(`‚ùå Erreur r√©cup√©ration donn√©es √©tendues trading: ${error.message}`, 'ERROR');
        return [];
    }
}

// üÜï NOUVELLE FONCTION: Agr√©ger les donn√©es depuis un timeframe inf√©rieur (fallback pour INSUFFICIENT_DATA)
async function aggregateDataFromLowerTimeframe(symbol, lowerTimeframe, targetTimeframe) {
    try {
        console.log(`üîÑ [TRADING] Tentative d'agr√©gation ${symbol}: ${lowerTimeframe} ‚Üí ${targetTimeframe}`);
        
        // Mapping des multipliers pour l'agr√©gation
        const aggregationMap = {
            '15m_to_1h': 4,   // 4 bougies 15m = 1 bougie 1h
            '15m_to_4h': 16,  // 16 bougies 15m = 1 bougie 4h
            '1h_to_4h': 4     // 4 bougies 1h = 1 bougie 4h
        };
        
        const aggregationKey = `${lowerTimeframe}_to_${targetTimeframe}`;
        const multiplier = aggregationMap[aggregationKey];
        
        if (!multiplier) {
            console.warn(`‚ö†Ô∏è [TRADING] Agr√©gation non support√©e: ${lowerTimeframe} ‚Üí ${targetTimeframe}`);
            return [];
        }
        
        // R√©cup√©rer plus de donn√©es du timeframe inf√©rieur
        const requiredCandles = 1000; // Maximum pour avoir assez de donn√©es
        const lowerData = await getKlineData(symbol, requiredCandles, lowerTimeframe);
        
        if (lowerData.length < multiplier) {
            console.warn(`‚ö†Ô∏è [TRADING] Pas assez de donn√©es ${lowerTimeframe} pour agr√©gation: ${lowerData.length}/${multiplier}`);
            return [];
        }
        
        // Agr√©ger les donn√©es
        const aggregatedData = [];
        for (let i = 0; i < lowerData.length; i += multiplier) {
            const chunk = lowerData.slice(i, i + multiplier);
            if (chunk.length === multiplier) {
                const aggregatedCandle = {
                    timestamp: chunk[0].timestamp,
                    open: chunk[0].open,
                    high: Math.max(...chunk.map(c => c.high)),
                    low: Math.min(...chunk.map(c => c.low)),
                    close: chunk[chunk.length - 1].close,
                    volume: chunk.reduce((sum, c) => sum + c.volume, 0)
                };
                aggregatedData.push(aggregatedCandle);
            }
        }
        
        console.log(`‚úÖ [TRADING] Agr√©gation r√©ussie: ${lowerData.length} bougies ${lowerTimeframe} ‚Üí ${aggregatedData.length} bougies ${targetTimeframe}`);
        return aggregatedData;
        
    } catch (error) {
        console.error(`‚ùå [TRADING] Erreur agr√©gation ${symbol}:`, error);
        return [];
    }
}

function calculatePositionSize() {
    // üéØ NOUVELLE STRAT√âGIE: 50% du solde avec levier x2
    const availableBalance = balance.totalEquity || balance.available || 1000; // Fallback si balance pas disponible
    const positionValue = availableBalance * 0.5; // 50% du solde
    
    log(`üí∞ Calcul position: Solde disponible ${availableBalance.toFixed(2)}$ ‚Üí Position ${positionValue.toFixed(2)}$ (50% + levier x2)`, 'INFO');
    
    return Math.max(positionValue, 10); // Minimum 10$
}

function hasOpenPosition(symbol) {
    return openPositions.some(pos => pos.symbol === symbol && pos.status === 'OPEN');
}

// üÜï NOUVELLE FONCTION: V√©rifier si on peut ouvrir une nouvelle position
function canOpenNewPosition(symbol) {
    // V√©rifier si on a d√©j√† une position sur ce symbole
    if (hasOpenPosition(symbol)) {
        return { canOpen: false, reason: 'Position d√©j√† ouverte sur ce symbole' };
    }
    
    // V√©rifier la limite de positions simultan√©es
    if (openPositions.length >= MAX_SIMULTANEOUS_POSITIONS) {
        return { canOpen: false, reason: `Limite de ${MAX_SIMULTANEOUS_POSITIONS} positions simultan√©es atteinte` };
    }
    
    // V√©rifier le cooldown (1 minute apr√®s fermeture)
    if (isPairInCooldown(symbol)) {
        const remainingMinutes = getRemainingCooldown(symbol);
        return { canOpen: false, reason: `${symbol} en cooldown encore ${remainingMinutes} minutes` };
    }
    
    // üÜï AM√âLIORATION: V√©rifier le cooldown 12h pour paires d√©j√† trad√©es
    if (isTradedPairInCooldown(symbol)) {
        const remainingHours = getRemainingTradedCooldown(symbol);
        return { canOpen: false, reason: `${symbol} d√©j√† trad√© r√©cemment - Cooldown encore ${remainingHours} heures` };
    }
    
    // V√©rifier le capital disponible
    const positionValue = calculatePositionSize();
    if (positionValue < 10) {
        return { canOpen: false, reason: 'Capital insuffisant pour ouvrir une position' };
    }
    
    return { canOpen: true, reason: 'Conditions remplies pour ouvrir une position' };
}

async function openPosition(symbol, selectedPair) {
    // üéØ NOUVELLE V√âRIFICATION: Utiliser la fonction de v√©rification centralis√©e
    const canOpen = canOpenNewPosition(symbol);
    
    if (!canOpen.canOpen) {
        log(`‚ö†Ô∏è ${symbol}: ${canOpen.reason}`, 'WARNING');
        return false;
    }
    
    // Log informatif sur le nombre de positions disponibles
    const availableSlots = MAX_SIMULTANEOUS_POSITIONS - openPositions.length;
    log(`üìä Ouverture position ${symbol} - ${availableSlots} slots disponibles sur ${MAX_SIMULTANEOUS_POSITIONS}`, 'INFO');
    
    const positionValue = calculatePositionSize();
    
    try {
        // üéØ NOUVELLE STRAT√âGIE: Toujours levier x2
        await setLeverage(symbol, 2);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const currentPrice = selectedPair.price;
        const quantity = (positionValue / currentPrice).toFixed(6);
        
        log(`üîÑ Ouverture position LONG ${symbol}...`, 'INFO');
        log(`üí∞ Prix: ${currentPrice} | Quantit√©: ${quantity} | Valeur: ${positionValue.toFixed(2)} USDT (Levier x2)`, 'INFO');
        log(`üéØ Raison: Paire positive 24h (+${selectedPair.change24h.toFixed(2)}%)`, 'INFO');
        
        const orderData = {
            symbol: symbol,
            productType: "USDT-FUTURES",
            marginMode: "isolated",
            marginCoin: "USDT",
            size: quantity,
            side: "buy",
            tradeSide: "open",
            orderType: "market",
            clientOid: `${Date.now()}_${symbol}`
        };
        
        const orderResult = await makeRequest('/bitget/api/v2/mix/order/place-order', {
            method: 'POST',
            body: JSON.stringify(orderData)
        });
        
        if (!orderResult || orderResult.code !== '00000') {
            log(`‚ùå √âchec ouverture position ${symbol}: ${orderResult?.msg || 'Erreur inconnue'}`, 'ERROR');
            return false;
        }
        
        log(`‚úÖ Position ouverte: ${symbol} - Ordre ID: ${orderResult.data.orderId}`, 'SUCCESS');
        log(`üìä Positions ouvertes: ${openPositions.length + 1}/${MAX_SIMULTANEOUS_POSITIONS}`, 'INFO');
        
        // üÜï AM√âLIORATION: Ajouter cooldown 12h pour cette paire (emp√™cher re-trade imm√©diat)
        addTradedPairCooldown(symbol);
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // üéØ NOUVELLE STRAT√âGIE: Pas de stop loss automatique, surveillance PnL √† +2%
        log(`üéØ Position ouverte sans stop loss - Surveillance PnL active pour fermeture √† +2%`, 'INFO');
        
        const position = {
            id: Date.now(),
            symbol: symbol,
            side: 'LONG',
            size: positionValue,
            quantity: quantity,
            entryPrice: currentPrice,
            status: 'OPEN',
            timestamp: new Date().toISOString(),
            orderId: orderResult.data.orderId,
            stopLossId: null, // Pas de stop loss dans la nouvelle strat√©gie
            currentStopPrice: null,
            highestPrice: currentPrice,
            reason: `Paire positive 24h (+${selectedPair.change24h.toFixed(2)}%)`,
            change24h: selectedPair.change24h,
            targetPnL: config.targetPnL // üÜï Objectif configurable
        };
        
        openPositions.push(position);
        botStats.totalPositions++;
        
        log(`üöÄ Position compl√®te: ${symbol} LONG ${positionValue.toFixed(2)} USDT @ ${currentPrice.toFixed(4)}`, 'SUCCESS');
        log(`üéØ Objectif: Fermeture automatique √† +${config.targetPnL}% de PnL`, 'INFO');
        log(`üìà Performance 24h: +${selectedPair.change24h.toFixed(2)}%`, 'INFO');
        
        updatePositionsDisplay();
        await refreshBalance();
        
        return true;
    } catch (error) {
        log(`‚ùå Erreur ouverture position ${symbol}: ${error.message}`, 'ERROR');
        return false;
    }
}

// REMOVED: syncLocalPositions function - merged into syncAndCheckPositions
// This eliminates duplication and ensures consistent handling

// üÜï NOUVELLE FONCTION: R√©cup√©rer les positions actives depuis l'API
async function fetchActivePositionsFromAPI() {
    try {
        const result = await makeRequest('/bitget/api/v2/mix/position/all-position?productType=USDT-FUTURES');
        
        if (result && result.code === '00000' && result.data) {
            return result.data.filter(pos => parseFloat(pos.total) > 0);
        }
        
        return [];
    } catch (error) {
        log(`‚ùå Erreur r√©cup√©ration positions API: ${error.message}`, 'ERROR');
        return [];
    }
}

async function createEmergencyStopLoss(position, stopPrice) {
    try {
        const stopLossData = {
            planType: "normal_plan",
            symbol: position.symbol,
            productType: "USDT-FUTURES",
            marginMode: "isolated",
            marginCoin: "USDT",
            size: position.quantity.toString(),
            triggerPrice: parseFloat(stopPrice.toFixed(8)).toString(),
            triggerType: "mark_price",
            side: "sell",
            tradeSide: "close",
            orderType: "market",
            clientOid: `emergency_stop_${Date.now()}_${position.symbol}`,
            reduceOnly: "YES"
        };
        
        const result = await makeRequestWithRetry('/bitget/api/v2/mix/order/place-plan-order', {
            method: 'POST',
            body: JSON.stringify(stopLossData)
        });
        
        if (result && result.code === '00000') {
            position.stopLossId = result.data.orderId;
            log(`üÜò Stop Loss d'urgence cr√©√© avec ID: ${result.data.orderId}`, 'SUCCESS');
            return true;
        } else {
            log(`‚ùå Erreur cr√©ation stop loss d'urgence: ${result?.msg || 'Erreur inconnue'}`, 'ERROR');
            return false;
        }
    } catch (error) {
        log(`‚ùå Exception cr√©ation stop loss d'urgence: ${error.message}`, 'ERROR');
        return false;
    }
}

// üéØ NOUVELLE FONCTION: Surveillance PnL et fermeture automatique √† +2%
async function monitorPnLAndClose() {
    if (!botRunning || openPositions.length === 0) return;
    
    try {
        for (const position of openPositions) {
            const currentPrice = await getCurrentPrice(position.symbol);
            if (!currentPrice) {
                log(`‚ö†Ô∏è ${position.symbol}: Impossible de r√©cup√©rer le prix`, 'WARNING');
                continue;
            }
            
            // Calculer le PnL en pourcentage
            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
            position.currentPrice = currentPrice;
            position.pnlPercent = pnlPercent;
            
            // Mettre √† jour le prix le plus haut
            if (currentPrice > position.highestPrice) {
                position.highestPrice = currentPrice;
            }
            
            // üéØ FERMETURE AUTOMATIQUE √Ä +2%
            if (pnlPercent >= position.targetPnL) {
                log(`üéØ ${position.symbol}: Objectif atteint +${pnlPercent.toFixed(2)}% ‚â• +${position.targetPnL}% - Fermeture automatique!`, 'SUCCESS');
                
                const closed = await closePositionAtMarket(position);
                if (closed) {
                    log(`‚úÖ Position ferm√©e avec succ√®s: ${position.symbol} (+${pnlPercent.toFixed(2)}%)`, 'SUCCESS');
                    
                    // Ajouter cooldown d'1 minute (pour √©viter re-ouverture imm√©diate)
                    addPositionCooldown(position.symbol);
                    
                    // Mettre √† jour les stats
                    botStats.totalClosedPositions++;
                    if (pnlPercent > 0) {
                        botStats.winningPositions++;
                        botStats.totalWinAmount += (position.size * pnlPercent / 100);
                    }
                    
                    // Supprimer de la liste des positions ouvertes
                    const index = openPositions.findIndex(p => p.id === position.id);
                    if (index !== -1) {
                        openPositions.splice(index, 1);
                    }
                    
                    // üÜï AM√âLIORATION: D√©clencher imm√©diatement une nouvelle s√©lection si un emplacement est libre
                    const availableSlots = MAX_SIMULTANEOUS_POSITIONS - openPositions.length;
                    if (availableSlots > 0) {
                        log(`üîÑ Position ferm√©e - D√©clenchement imm√©diat d'une nouvelle s√©lection (${availableSlots} emplacements libres)`, 'INFO');
                        setTimeout(() => {
                            if (typeof tradingLoop === 'function') {
                                tradingLoop();
                            }
                        }, 2000); // Attendre 2 secondes pour que le cooldown soit actif
                    }
                } else {
                    log(`‚ùå √âchec fermeture position ${position.symbol}`, 'ERROR');
                }
            } else {
                // Log de suivi (moins fr√©quent pour √©viter le spam)
                if (Date.now() - (position.lastPnLLog || 0) > 30000) { // Toutes les 30 secondes
                    log(`üìä ${position.symbol}: PnL ${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}% (Objectif: +${position.targetPnL}%)`, 'DEBUG');
                    position.lastPnLLog = Date.now();
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        updatePositionsDisplay();
        
    } catch (error) {
        log(`‚ùå Erreur surveillance PnL: ${error.message}`, 'ERROR');
    }
}

// üÜï NOUVELLE FONCTION: Fermer une position au march√©
async function closePositionAtMarket(position) {
    try {
        const orderData = {
            symbol: position.symbol,
            productType: "USDT-FUTURES",
            marginMode: "isolated",
            marginCoin: "USDT",
            size: position.quantity.toString(),
            side: "sell",
            tradeSide: "close",
            orderType: "market",
            clientOid: `close_${Date.now()}_${position.symbol}`
        };
        
        log(`üîÑ Fermeture position ${position.symbol} au march√©...`, 'INFO');
        
        const result = await makeRequestWithRetry('/bitget/api/v2/mix/order/place-order', {
            method: 'POST',
            body: JSON.stringify(orderData)
        });
        
        if (result && result.code === '00000') {
            log(`‚úÖ Ordre de fermeture plac√©: ${position.symbol} - ID: ${result.data.orderId}`, 'SUCCESS');
            return true;
        } else {
            log(`‚ùå Erreur fermeture position ${position.symbol}: ${result?.msg || 'Erreur inconnue'}`, 'ERROR');
            return false;
        }
        
    } catch (error) {
        log(`‚ùå Exception fermeture position ${position.symbol}: ${error.message}`, 'ERROR');
        return false;
    }
}

// üÜï NOUVELLE FONCTION: Ajouter un cooldown apr√®s fermeture de position (1 minute)
function addPositionCooldown(symbol) {
    const cooldownEnd = Date.now() + (60 * 1000); // 1 minute
    positionCooldowns.set(symbol, cooldownEnd);
    log(`‚è∞ Cooldown 1min activ√© pour ${symbol}`, 'INFO');
}

// üÜï NOUVELLE FONCTION: V√©rifier si une paire est en cooldown (1 minute)
function isPairInCooldown(symbol) {
    const cooldownEnd = positionCooldowns.get(symbol);
    if (!cooldownEnd) return false;
    
    const now = Date.now();
    if (now >= cooldownEnd) {
        positionCooldowns.delete(symbol);
        return false;
    }
    
    return true;
}

// üÜï AM√âLIORATION: Ajouter un cooldown 12h pour les paires d√©j√† trad√©es
function addTradedPairCooldown(symbol) {
    const cooldownEnd = Date.now() + (12 * 60 * 60 * 1000); // 12 heures
    tradedPairsCooldown.set(symbol, cooldownEnd);
    log(`‚è∞ Cooldown 12h activ√© pour ${symbol} (paire trad√©e)`, 'INFO');
}

// üÜï AM√âLIORATION: V√©rifier si une paire trad√©e est en cooldown 12h
function isTradedPairInCooldown(symbol) {
    const cooldownEnd = tradedPairsCooldown.get(symbol);
    if (!cooldownEnd) return false;
    
    const now = Date.now();
    if (now >= cooldownEnd) {
        tradedPairsCooldown.delete(symbol);
        return false;
    }
    
    return true;
}

// üÜï AM√âLIORATION: Obtenir le temps restant du cooldown 1 minute
function getRemainingCooldown(symbol) {
    const cooldownEnd = positionCooldowns.get(symbol);
    if (!cooldownEnd) return 0;
    
    const remaining = Math.max(0, cooldownEnd - Date.now());
    return Math.ceil(remaining / 60000); // En minutes
}

// üÜï AM√âLIORATION: Obtenir le temps restant du cooldown 12h
function getRemainingTradedCooldown(symbol) {
    const cooldownEnd = tradedPairsCooldown.get(symbol);
    if (!cooldownEnd) return 0;
    
    const remaining = Math.max(0, cooldownEnd - Date.now());
    return Math.ceil(remaining / (60 * 60 * 1000)); // En heures
}

async function updatePositionsPnL() {
    if (openPositions.length === 0) return;
    
    try {
        const result = await makeRequest('/bitget/api/v2/mix/position/all-position?productType=USDT-FUTURES');
        
        if (result && result.code === '00000' && result.data) {
            const apiPositions = result.data.filter(pos => parseFloat(pos.total) > 0);
            
            openPositions.forEach(localPos => {
                const apiPos = apiPositions.find(pos => pos.symbol === localPos.symbol);
                if (apiPos) {
                    localPos.currentPrice = parseFloat(apiPos.markPrice);
                    localPos.unrealizedPnL = parseFloat(apiPos.unrealizedPL || 0);
                    localPos.pnlPercentage = ((localPos.currentPrice - localPos.entryPrice) / localPos.entryPrice) * 100;
                }
            });
            
            updatePositionsDisplay();
        }
    } catch (error) {
        // Mise √† jour silencieuse
    }
}

function updatePositionsDisplay() {
    // UI removed: no-op
}

async function importExistingPositions() {
    try {
        log('üîÑ Importation des positions existantes depuis Bitget...', 'INFO');
        
        if (typeof makeRequest !== 'function') {
            log('‚ùå Fonction makeRequest non disponible pour l\'importation', 'ERROR');
            return;
        }
        
        if (!config.apiKey || !config.secretKey || !config.passphrase) {
            log('‚ùå Configuration API manquante pour l\'importation', 'ERROR');
            return;
        }
        
        log('üîç R√©cup√©ration des positions depuis l\'API Bitget...', 'DEBUG');
        const result = await makeRequest('/bitget/api/v2/mix/position/all-position?productType=USDT-FUTURES');
        
        log(`üìä R√©ponse API re√ßue: ${result ? 'OK' : 'NULL'}`, 'DEBUG');
        
        if (result && result.code === '00000' && result.data) {
            log(`üìä Donn√©es brutes re√ßues: ${result.data.length} positions total`, 'DEBUG');
            const apiPositions = result.data.filter(pos => parseFloat(pos.total) > 0);
            log(`üìä Positions actives filtr√©es: ${apiPositions.length}`, 'DEBUG');
            
            if (apiPositions.length === 0) {
                log('‚ÑπÔ∏è Aucune position existante trouv√©e sur Bitget', 'INFO');
                return;
            }
            
            // NEW: Limit check before importing
            if (openPositions.length + apiPositions.length > MAX_SIMULTANEOUS_POSITIONS) {
                log(`‚ö†Ô∏è Import limit√©: Trop de positions (${openPositions.length + apiPositions.length} > ${MAX_SIMULTANEOUS_POSITIONS}) - Import partiel`, 'WARNING');
                const availableSlots = MAX_SIMULTANEOUS_POSITIONS - openPositions.length;
                apiPositions.splice(availableSlots); // Keep only what fits
            }
            
            apiPositions.forEach((pos, index) => {
                log(`üìç Position ${index + 1}: ${pos.symbol} ${pos.side || 'NO_SIDE'} - Size: ${pos.contractSize || 'NO_SIZE'} - Price: ${pos.markPrice || 'NO_PRICE'}`, 'DEBUG');
                log(`üìä Structure compl√®te: ${JSON.stringify(pos)}`, 'DEBUG');
            });
            
            let imported = 0;
            
            for (const apiPos of apiPositions) {
                const exists = openPositions.find(localPos => localPos.symbol === apiPos.symbol);
                
                if (!exists) {
                    const side = apiPos.side ? apiPos.side.toUpperCase() : 'LONG';
                    const contractSize = parseFloat(apiPos.contractSize || 0);
                    const markPrice = parseFloat(apiPos.markPrice || 0);
                    const averageOpenPrice = parseFloat(apiPos.averageOpenPrice || markPrice);
                    const unrealizedPL = parseFloat(apiPos.unrealizedPL || 0);
                    
                    log(`üîç Donn√©es position ${apiPos.symbol}: side=${apiPos.side}, contractSize=${apiPos.contractSize}, markPrice=${apiPos.markPrice}`, 'DEBUG');
                    
                    const position = {
                        id: Date.now() + Math.random(),
                        symbol: apiPos.symbol,
                        side: side,
                        size: Math.abs(contractSize * markPrice),
                        quantity: Math.abs(contractSize),
                        entryPrice: averageOpenPrice,
                        status: 'OPEN',
                        timestamp: new Date().toISOString(),
                        orderId: `imported_${Date.now()}`,
                        stopLossId: null,
                        currentStopPrice: null,
                        highestPrice: markPrice,
                        currentPrice: markPrice,
                        unrealizedPnL: unrealizedPL,
                        pnlPercentage: averageOpenPrice > 0 ? ((markPrice - averageOpenPrice) / averageOpenPrice) * 100 : 0,
                        reason: 'üì• Position import√©e depuis Bitget'
                    };
                    
                    if (position.symbol && position.size > 0 && position.entryPrice > 0) {
                        openPositions.push(position);
                        imported++;
                        
                        log(`üì• Position import√©e: ${position.symbol} ${position.side} ${position.size.toFixed(2)} USDT @ ${position.entryPrice.toFixed(4)}`, 'SUCCESS');
                    } else {
                        log(`‚ö†Ô∏è Position ${apiPos.symbol} ignor√©e - Donn√©es invalides`, 'WARNING');
                    }
                }
            }
            
            if (imported > 0) {
                log(`‚úÖ ${imported} position(s) import√©e(s) avec succ√®s!`, 'SUCCESS');
                log(`‚ö†Ô∏è Positions import√©es SANS stop loss - Le syst√®me va les prot√©ger automatiquement`, 'WARNING');
                
                updatePositionsDisplay();
                updateStats();
                
                setTimeout(() => {
                    manageTrailingStops();
                }, 2000);
            } else {
                log('‚ÑπÔ∏è Toutes les positions existantes sont d√©j√† dans le syst√®me', 'INFO');
            }
        } else {
            log('‚ùå Erreur lors de l\'importation des positions', 'ERROR');
        }
    } catch (error) {
        log(`‚ùå Erreur importation positions: ${error.message}`, 'ERROR');
    }
}

window.importExistingPositions = importExistingPositions;
window.canOpenNewPosition = canOpenNewPosition;
window.syncAndCheckPositions = syncAndCheckPositions;
window.fetchActivePositionsFromAPI = fetchActivePositionsFromAPI;
window.makeRequestWithRetry = makeRequestWithRetry;

// üß™ FONCTION DE TEST: Tester les nouveaux param√®tres MACD par timeframe
async function testMACDParameters(symbol = 'BTCUSDT') {
    console.log('üß™ Test des param√®tres MACD adaptatifs par timeframe...');
    
    const testSymbol = symbol;
    const timeframes = ['4h', '1h', '15m'];
    
    for (const tf of timeframes) {
        console.log(`\nüîç Test ${tf.toUpperCase()}:`);
        
        const params = getMACDParameters(tf);
        console.log(`   Param√®tres: Fast=${params.fast}, Slow=${params.slow}, Signal=${params.signal}`);
        console.log(`   Bougies requises: ${params.minCandles}`);
        
        try {
            const analysis = await analyzePairMACD(testSymbol, tf);
            console.log(`   ‚úÖ Analyse r√©ussie: ${analysis.signal}`);
            console.log(`   üìä Raison: ${analysis.reason}`);
        } catch (error) {
            console.log(`   ‚ùå Erreur analyse: ${error.message}`);
        }
        
        // D√©lai entre les tests
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log('\n‚úÖ Test termin√©. V√©rifiez les r√©sultats ci-dessus.');
}

// Rendre la fonction accessible globalement
window.testMACDParameters = testMACDParameters;

// NEW: Merged function combining syncLocalPositions and checkPositionsStatus
async function syncAndCheckPositions() {
    if (openPositions.length === 0) return [];
    
    try {
        const result = await makeRequest('/bitget/api/v2/mix/position/all-position?productType=USDT-FUTURES');
        
        if (result && result.code === '00000' && result.data) {
            const apiPositions = result.data.filter(pos => parseFloat(pos.total) > 0);
            const currentSymbols = apiPositions.map(pos => pos.symbol);
            
            const closedPositions = openPositions.filter(localPos => 
                !currentSymbols.includes(localPos.symbol)
            );
            
            if (closedPositions.length > 0) {
                for (const closedPos of closedPositions) {
                    log(`üîö Position ferm√©e d√©tect√©e: ${closedPos.symbol} (Stop Loss d√©clench√© ou fermeture manuelle)`, 'SUCCESS');
                    
                    botStats.totalClosedPositions++;
                    const pnl = closedPos.unrealizedPnL || 0;
                    
                    if (pnl > 0) {
                        botStats.winningPositions++;
                        botStats.totalWinAmount += pnl;
                        log(`üü¢ Position gagnante: +${pnl.toFixed(2)}$ (Total: ${botStats.winningPositions} gagnantes)`, 'SUCCESS');
                    } else if (pnl < 0) {
                        botStats.losingPositions++;
                        botStats.totalLossAmount += pnl;
                        log(`üî¥ Position perdante: ${pnl.toFixed(2)}$ (Total: ${botStats.losingPositions} perdantes)`, 'WARNING');
                    }
                    
                    // Cancel orphaned stop losses (from checkPositionsStatus)
                    if (closedPos.stopLossId) {
                        try {
                            const cancelResult = await makeRequest('/bitget/api/v2/mix/order/cancel-plan-order', {
                                method: 'POST',
                                body: JSON.stringify({
                                    symbol: closedPos.symbol,
                                    productType: "USDT-FUTURES",
                                    marginCoin: "USDT",
                                    orderId: closedPos.stopLossId
                                })
                            });
                            
                            if (cancelResult && cancelResult.code === '00000') {
                                log(`‚úÖ Stop Loss ${closedPos.symbol} annul√© automatiquement`, 'SUCCESS');
                            }
                        } catch (error) {
                            log(`‚ö†Ô∏è Erreur annulation stop loss ${closedPos.symbol}: ${error.message}`, 'WARNING');
                        }
                    }
                }
                
                openPositions = openPositions.filter(localPos => 
                    currentSymbols.includes(localPos.symbol)
                );
                
                updatePositionsDisplay();
                updateStats();
                await refreshBalance();
                
                log(`üìä ${closedPositions.length} position(s) ferm√©e(s) - Synchronisation effectu√©e`, 'SUCCESS');
            }
            
            return apiPositions;
        }
    } catch (error) {
        log(`‚ùå Erreur synchronisation positions: ${error.message}`, 'ERROR');
        return [];
    }
}

// üß™ FONCTION DE TEST: V√©rifier que toutes les corrections fonctionnent
async function testTradingFixes() {
    console.log('üß™ Test des corrections de trading...');
    
    try {
        // Test 1: V√©rifier que la fonction dupliqu√©e a √©t√© supprim√©e
        if (typeof analyzeMultiTimeframe === 'undefined') {
            console.log('‚úÖ Fix 1: Fonction dupliqu√©e analyzeMultiTimeframe supprim√©e');
        } else {
            console.log('‚ùå Fix 1: Fonction dupliqu√©e analyzeMultiTimeframe encore pr√©sente');
        }
        
        // Test 2: V√©rifier que la fonction d'agr√©gation existe
        if (typeof aggregateDataFromLowerTimeframe === 'function') {
            console.log('‚úÖ Fix 2: Fonction d\'agr√©gation pour INSUFFICIENT_DATA ajout√©e');
        } else {
            console.log('‚ùå Fix 2: Fonction d\'agr√©gation manquante');
        }
        
        // Test 3: V√©rifier que la fonction de retry existe
        if (typeof makeRequestWithRetry === 'function') {
            console.log('‚úÖ Fix 4: Fonction de retry pour stop loss ajout√©e');
        } else {
            console.log('‚ùå Fix 4: Fonction de retry manquante');
        }
        
        // Test 4: V√©rifier que la fonction merg√©e existe
        if (typeof syncAndCheckPositions === 'function') {
            console.log('‚úÖ Fix 5: Fonction de synchronisation merg√©e cr√©√©e');
        } else {
            console.log('‚ùå Fix 5: Fonction de synchronisation merg√©e manquante');
        }
        
        // Test 5: V√©rifier que les anciens noms n'existent plus
        if (typeof syncLocalPositions === 'undefined' && typeof checkPositionsStatus === 'undefined') {
            console.log('‚úÖ Fix 5: Anciennes fonctions de synchronisation supprim√©es');
        } else {
            console.log('‚ùå Fix 5: Anciennes fonctions de synchronisation encore pr√©sentes');
        }
        
        // Test 6: V√©rifier la configuration trailing stop
        if (config.trailingStopSettings && config.trailingStopSettings.trailingPercent) {
            console.log('‚úÖ Fix G√©n√©ral: Configuration trailing stop configurable');
        } else {
            console.log('‚ö†Ô∏è Fix G√©n√©ral: Configuration trailing stop utilise les valeurs par d√©faut');
        }
        
        console.log('‚úÖ Test des corrections termin√©');
        
    } catch (error) {
        console.error('‚ùå Erreur lors du test des corrections:', error);
    }
}

// Rendre la fonction accessible globalement
window.testTradingFixes = testTradingFixes;

console.log('‚úÖ Trading fixes applied successfully - call testTradingFixes() to verify');